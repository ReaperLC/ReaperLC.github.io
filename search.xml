<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>值得关注的跨平台技术：Flutter</title>
      <link href="/2019/01/22/%E5%85%B6%E4%BB%96/%E5%80%BC%E5%BE%97%E5%85%B3%E6%B3%A8%E7%9A%84%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%8A%80%E6%9C%AF%EF%BC%9AFlutter/"/>
      <url>/2019/01/22/%E5%85%B6%E4%BB%96/%E5%80%BC%E5%BE%97%E5%85%B3%E6%B3%A8%E7%9A%84%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%8A%80%E6%9C%AF%EF%BC%9AFlutter/</url>
      
        <content type="html"><![CDATA[<h2 id="flutter中文网"><a href="#flutter中文网" class="headerlink" title="flutter中文网"></a>flutter中文网</h2><p>Flutter是谷歌的移动UI框架，可以快速在iOS和Android上构建高质量的原生用户界面。 Flutter可以与现有的代码一起工作。在全世界，Flutter正在被越来越多的开发者和组织使用，并且Flutter是完全免费、开源的。可以前往<a href="https://flutterchina.club/" target="_blank" rel="noopener">flutter中文网</a>查看相关详情</p><h2 id="flutter开发引导"><a href="#flutter开发引导" class="headerlink" title="flutter开发引导"></a>flutter开发引导</h2><p>关于环境搭建,后面会具体提到flutter的安装,工具类的安装,参考下面的引导可以帮助你更快的上手新型的跨平台开发<a href="https://codelabs.flutter-io.cn/codelabs/first-flutter-app-pt2-cn/index.html#0" target="_blank" rel="noopener">指路</a></p><h2 id="安装Flutter-SDK"><a href="#安装Flutter-SDK" class="headerlink" title="安装Flutter SDK"></a>安装Flutter SDK</h2><pre class=" language-bash"><code class="language-bash">//1.终端中输入以下指令克隆项目<span class="token function">git</span> clone -b beta https://github.com/flutter/flutter.git//2. 导出到Flutter保存路径<span class="token function">export</span> PATH<span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">pwd</span><span class="token variable">`</span></span>/flutter/bin:<span class="token variable">$PATH</span></code></pre><p>终端中一次输入以下命令解决镜像问题</p><pre class=" language-bash"><code class="language-bash"><span class="token function">export</span> PUB_HOSTED_URL<span class="token operator">=</span>https://pub.flutter-io.cn<span class="token function">export</span> FLUTTER_STORAGE_BASE_URL<span class="token operator">=</span>https://storage.flutter-io.cn<span class="token function">git</span> clone -b dev https://github.com/flutter/flutter.git<span class="token function">export</span> PATH<span class="token operator">=</span><span class="token string">"<span class="token variable">$PWD</span>/flutter/bin:<span class="token variable">$PATH</span>"</span><span class="token function">cd</span> ./flutterflutter doctor</code></pre><p>环境安装无误,最终执行结果如下:</p><pre class=" language-bash"><code class="language-bash">Doctor summary <span class="token punctuation">(</span>to see all details, run flutter doctor -v<span class="token punctuation">)</span>:<span class="token punctuation">[</span>✓<span class="token punctuation">]</span> Flutter <span class="token punctuation">(</span>Channel beta, v0.5.1, on Mac OS X 10.13.5 17F77, locale zh-Hans-CN<span class="token punctuation">)</span><span class="token punctuation">[</span>✓<span class="token punctuation">]</span> Android toolchain - develop <span class="token keyword">for</span> Android devices <span class="token punctuation">(</span>Android SDK 27.0.3<span class="token punctuation">)</span><span class="token punctuation">[</span>✓<span class="token punctuation">]</span> iOS toolchain - develop <span class="token keyword">for</span> iOS devices <span class="token punctuation">(</span>Xcode 9.4.1<span class="token punctuation">)</span><span class="token punctuation">[</span>✓<span class="token punctuation">]</span> Android Studio <span class="token punctuation">(</span>version 3.1<span class="token punctuation">)</span><span class="token punctuation">[</span>✓<span class="token punctuation">]</span> IntelliJ IDEA Ultimate Edition <span class="token punctuation">(</span>version 2018.1.1<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token operator">!</span><span class="token punctuation">]</span> VS Code <span class="token punctuation">(</span>version 1.24.1<span class="token punctuation">)</span><span class="token punctuation">[</span>✓<span class="token punctuation">]</span> Connected devices <span class="token punctuation">(</span>2 available<span class="token punctuation">)</span></code></pre><h2 id="设定开发环境"><a href="#设定开发环境" class="headerlink" title="设定开发环境"></a>设定开发环境</h2><blockquote><ul><li>开启开发者模式（developer mode的 <a href="https://flutter.io/docs/get-started/install/macos#set-up-your-android-device" target="_blank" rel="noopener">Android</a>) 和 <a href="https://flutter.io/docs/get-started/install/macos#deploy-to-ios-devices" target="_blank" rel="noopener">iOS</a> 真机；</li><li><a href="https://flutter.io/docs/get-started/install/macos#set-up-the-ios-simulator" target="_blank" rel="noopener">iOS 模拟器</a>；（需要安装 XCode 等）</li><li><a href="https://flutter.io/docs/get-started/install/macos#set-up-the-android-emulator" target="_blank" rel="noopener">Android 模拟器</a>。（需要安装 Android Studio 等）</li></ul></blockquote><h2 id="创建第一个Flutter-Demo"><a href="#创建第一个Flutter-Demo" class="headerlink" title="创建第一个Flutter Demo"></a>创建第一个Flutter Demo</h2>]]></content>
      
      
      <categories>
          
          <category> 跨平台 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 跨平台开发 </tag>
            
            <tag> flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>App启动速度优化</title>
      <link href="/2019/01/18/iOS%E5%BC%80%E5%8F%91/App%E5%90%AF%E5%8A%A8%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96%E7%AF%87/"/>
      <url>/2019/01/18/iOS%E5%BC%80%E5%8F%91/App%E5%90%AF%E5%8A%A8%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h2 id="App启动速度优化"><a href="#App启动速度优化" class="headerlink" title="App启动速度优化"></a>App启动速度优化</h2><p>关于App应用启动速度优化的话题：<a href="https://developer.apple.com/videos/play/wwdc2016/406/" target="_blank" rel="noopener">Session 406 Optimizing App Startup Time</a> ，该Session上Apple建议一个App完整的启动时间应该保证400ms之内,而若超过20s后还未完全启动App,那么App进程就会被系统杀死.而如何Debug和优化应用启动的时间,官方提出一系列方法来关注应用启动时执行main()前究竟干了些什么.而通过这个Session,你会了解到以下内容:</p><blockquote><ul><li><strong>如何获得应用加载的时间</strong></li><li><strong>执行程序入门的代码前App加载过程中的流程</strong></li><li><strong>如何优化App的加载时间</strong></li></ul></blockquote><h2 id="测量Pre-main-Time"><a href="#测量Pre-main-Time" class="headerlink" title="测量Pre-main Time"></a>测量Pre-main Time</h2><p>一个App在执行main函数前包括app delegate的系列方法如<font color="#DC143C">applicationWillFinishLaunching</font>时,会做许多系统级别的准备.而在iOS10之前,开发者很难清楚自己App为何启动加载慢.而通过在工程的scheme中添加环境变量<font color="#DC143C"><strong>DYLD_PRINT_STATISTICS</strong></font>,设置Value为1,App启动加载时就会有启动过程的日志输出. 添加方法如下：</p><p><img src="https://github.com/ReaperLC/Hello-World/blob/master/resource/iOS_bl.png?raw=true" alt=""></p><p>现在(iOS 10之后)Apple对<font color="#DC143C"><strong>DYLD_PRINT_STATISTICS</strong></font>的日志输出结果进行了简化,使得更容易让开发者理解.</p><p><img src="https://github.com/ReaperLC/Hello-World/blob/master/resource/iOS_speed.png?raw=true" alt=""></p><p>输出内容展示了系统调用main()函前主要进行的工作内容和时间花费,Session上也对每一阶段加载过程具体内容进行了详细的叙述,有兴趣地可观看该Session.</p><h2 id="启动优化"><a href="#启动优化" class="headerlink" title="启动优化"></a>启动优化</h2><p>那么如何尽可能的减少pre-main花费的时间呢,主要就从输出日志给出的四个阶段下手:</p><h4 id="1、对动态库加载的时间优化"><a href="#1、对动态库加载的时间优化" class="headerlink" title="1、对动态库加载的时间优化"></a>1、对动态库加载的时间优化</h4><p>每个App都进行动态库加载,其中系统级别的动态库占据了绝大数,而针对系统级别的动态库都是经过系统高度优化的,不用担心时间的花费.开发者应该关注于自己集成到App的那些动态库,这也是最能消耗加载时间的地方.对此Apple建议减少在App里开发者的动态库集成或者有可能地将其多个动态库最终集成一个动态库后进行导入, 尽量保证将App现有的非系统级的动态库个数保证在6个以内. </p><h4 id="2、减少App的Objective-C类-分类和的唯一Selector的个数"><a href="#2、减少App的Objective-C类-分类和的唯一Selector的个数" class="headerlink" title="2、减少App的Objective-C类,分类和的唯一Selector的个数"></a>2、减少App的Objective-C类,分类和的唯一Selector的个数</h4><p>这样做主要是为了加快程序的整个动态链接, 在进行动态库的重定位和绑定(Rebase/binding)过程中减少指针修正的使用,加快程序机器码的生成.</p><h4 id="3、减少Objc运行初始化的时间花费"><a href="#3、减少Objc运行初始化的时间花费" class="headerlink" title="3、减少Objc运行初始化的时间花费"></a>3、减少Objc运行初始化的时间花费</h4><p>主要是类的注册,分类的注册,唯一选择器的存在,以及涉及子父类内存布局的Non Fragile ivars偏移的更新,都会影响Objective-C运行时初始化的时间消耗.</p><h4 id="4、使用initialize方法"><a href="#4、使用initialize方法" class="headerlink" title="4、使用initialize方法"></a>4、使用initialize方法</h4><p>大家都知道, +Load方法只要引入项目工程中,不管最后有没有引用,他都是调用了的,所以进行必要的初始化工作.用+initialize方法替换调用原先在OC的+load方法中执行初始代码工作,从而加快所有类文件的加载速度.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后演讲者对加载启动优化的整体概括了Session所要传达的内容:</p><blockquote><ul><li><strong>使用<font color="#DC143C"></font></strong>DYLD_PRINT_STATISTICS<strong>测试启动加载时间</strong></li><li><strong>减少自定义的动态库集成</strong></li><li><strong>精简原有的Objective-C类和代码</strong></li><li><strong>移除静态的初始化操作</strong></li><li><strong>使用更多的Swift代码</strong></li></ul></blockquote><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><ul><li><a href="https://developer.apple.com/videos/play/wwdc2016/406/" target="_blank" rel="noopener">WWDC 2016 Session 406 Optimizing App Startup Time</a></li><li><a href="http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/" target="_blank" rel="noopener">Objective-C Runtime</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS逆向工程</title>
      <link href="/2019/01/14/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/iOS%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B(%E9%9D%9E%E8%B6%8A%E7%8B%B1)/"/>
      <url>/2019/01/14/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/iOS%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B(%E9%9D%9E%E8%B6%8A%E7%8B%B1)/</url>
      
        <content type="html"><![CDATA[<h1 id="iOS逆向工程-非越狱"><a href="#iOS逆向工程-非越狱" class="headerlink" title="iOS逆向工程-非越狱"></a>iOS逆向工程-非越狱</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>软件逆向工程，指的是通过分析一个程序或系统的功能、结构或行为，将它的技术实现或细节推导出来的过程。当我们对一个软件的功能很感兴趣，却又拿不到它的源代码时，往往可以通过逆向工程来对它进行分析。</p><h2 id="运用"><a href="#运用" class="headerlink" title="运用"></a>运用</h2><p>逆向工程主要有两个作用：<br><strong>分析目标程序，拿到关键信息，可以归类于安全相关的逆向工程</strong></p><blockquote><ul><li>评定软件的安全级别</li><li>逆向恶意软件</li><li>检查软件后门</li></ul></blockquote><p><strong>借鉴他人的程序功能来开发自己的软件，可以归类于开发相关的逆向工程</strong></p><blockquote><ul><li>逆向系统API</li><li>借鉴别的软件</li></ul></blockquote><h2 id="脱壳"><a href="#脱壳" class="headerlink" title="脱壳"></a>脱壳</h2><p><a href="https://github.com/conradev/dumpdecrypted" target="_blank" rel="noopener">dumpdecrypted</a><br><a href="https://github.com/AloneMonkey/frida-ios-dump" target="_blank" rel="noopener">AloneMonkey</a></p><h4 id="AloneMonkey"><a href="#AloneMonkey" class="headerlink" title="AloneMonkey"></a>AloneMonkey</h4><p><a href="https://github.com/AloneMonkey/MonkeyDev/wiki/%E5%AE%89%E8%A3%85" target="_blank" rel="noopener">安装</a></p><h2 id="Dump"><a href="#Dump" class="headerlink" title="Dump"></a>Dump</h2><h2 id="Hook"><a href="#Hook" class="headerlink" title="Hook"></a>Hook</h2><h2 id="重签"><a href="#重签" class="headerlink" title="重签"></a>重签</h2><h4 id="完全重签名"><a href="#完全重签名" class="headerlink" title="完全重签名"></a>完全重签名</h4><p>证书，mobileprovision、Bundle ID 三者信息对应一致,这种重签名方式基本上与直接对代码进行签名的效果是一样的；<br>优点：有效期长、稳定性高；<br>缺点：维护成本较高，每一个重签名的ipa都必须修改Bundle ID 并且独享一套证书和mobileprovision文件；<br>适用范围：对签名效果稳定性有要求的公司和团队；</p><h4 id="不完全重签名"><a href="#不完全重签名" class="headerlink" title="不完全重签名"></a>不完全重签名</h4><p>只保证证书和mobileprovision对应一致，至于这两者与原ipa的Bundle ID 等信息是否一致则不考虑；<br>优点：看起来较方便维护；<br>缺点：实际上并没有对原ipa的签名进行完全替换，很容易重签名失败，稳定性不高，多则一两个月，少则三五天就可能发生签名失效，需要重新签名，慎用！！<br>适用范围：市面上出售企业证书进行重签名的个人卖家；</p><h2 id="常用签名工具"><a href="#常用签名工具" class="headerlink" title="常用签名工具"></a>常用签名工具</h2><h4 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h4><h4 id="AloneMonkey-1"><a href="#AloneMonkey-1" class="headerlink" title="AloneMonkey"></a>AloneMonkey</h4><h4 id="Xcode-自动化重签"><a href="#Xcode-自动化重签" class="headerlink" title="Xcode 自动化重签"></a>Xcode 自动化重签</h4>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逆向 </tag>
            
            <tag> 分析 </tag>
            
            <tag> 编码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Mac环境下Hexo搭建指南</title>
      <link href="/2018/11/16/Hexo%E6%90%AD%E5%BB%BA/Mac%E4%B8%8BHexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
      <url>/2018/11/16/Hexo%E6%90%AD%E5%BB%BA/Mac%E4%B8%8BHexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>安装Hexo前需要先安装Git和Node.js</p><h3 id="Git安装"><a href="#Git安装" class="headerlink" title="Git安装"></a>Git安装</h3><p>HomeBrew是一种包管理工具，可以帮助您方便快捷的安装与卸载软件。</p><pre class=" language-bash"><code class="language-bash">$ brew <span class="token function">install</span> <span class="token function">git</span></code></pre><p>安装结束后在命令行输入git后运行，如果屏幕上出现git命令的使用帮助，说明安装成功。</p><h3 id="SSH配置"><a href="#SSH配置" class="headerlink" title="SSH配置"></a>SSH配置</h3><p>首先检查本地是否已存在ssh-keys</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">ls</span> -a ~/.ssh/</code></pre><p>以上命令列出当前用户主目录下的.ssh目录中的所有文件，如果存在id_rsa和id_rsa.pub则跳过下一步，否则需要手动生成一组ssh-key</p><p>手动生成</p><pre class=" language-bash"><code class="language-bash">$ ssh-keygen -t rsa -C <span class="token string">"your_email@example.com"</span></code></pre><p>其中<a href="mailto:your_email@example.com" target="_blank" rel="noopener">your_email@example.com</a>换成自己的git帐号邮箱即可</p><p>生成的文件默认会放在之前提到的.ssh目录中，我们需要获得公钥的值，在命令行输入</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">cat</span> ~/.ssh/id_rsa.pub</code></pre><p>该命令将公钥文件中的值，也就是一个很长的字符串输出到命令行中，复制该值备用。</p><h3 id="Node-js安装"><a href="#Node-js安装" class="headerlink" title="Node.js安装"></a>Node.js安装</h3><p>Node是javascript的一种运行时环境，也是近年来非常流行的一门技术。安装Node.js的最佳方式是使用nvm。在命令行输入</p><pre class=" language-bash"><code class="language-bash">$ curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.29.0/install.sh <span class="token operator">|</span> <span class="token function">bash</span></code></pre><p>这条命令通过curl下载install.sh脚本，并执行脚本。待执行完成后，它会把nvm命令的执行路径放到~/.bashrc文件里，我们可以用cat命令来查看一下</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">cat</span> ~/.bashrc</code></pre><p>确认存在以上配置后，通过执行source命令来使得环境变量生效</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">source</span> ~/.bashrc</code></pre><p>至此我们就把nvm安装好了，可以通过以下命令查看nvm版本号</p><pre class=" language-bash"><code class="language-bash">$ nvm --version</code></pre><p>如果能正确打印出版本信息就证明nvm已经安装成功。接着通过执行以下命令来安装Node.js</p><pre class=" language-bash"><code class="language-bash">$ nvm <span class="token function">install</span> stable</code></pre><h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>上述环境配置完毕后，即可安装hexo</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">sudo</span> <span class="token function">npm</span> <span class="token function">install</span> -g hexo-cli</code></pre><p>npm是Node.js自带的一个包管理工具，用于安装和卸载Node模块。上面的命令将Hexo这个模块以全局的方式安装到我们的电脑中，是Hexo官方推荐的方式。但笔者在运行这条命令时，出现了如下的错误</p><pre class=" language-bash"><code class="language-bash"><span class="token function">npm</span> ERR<span class="token operator">!</span> Error: EACCES: permission denied, <span class="token function">mkdir</span> <span class="token string">'/usr/local/lib/node_modules/hexo-cli'</span><span class="token function">npm</span> ERR<span class="token operator">!</span>     at Error <span class="token punctuation">(</span>native<span class="token punctuation">)</span><span class="token function">npm</span> ERR<span class="token operator">!</span>  <span class="token punctuation">{</span> <span class="token punctuation">[</span>Error: EACCES: permission denied, <span class="token function">mkdir</span> <span class="token string">'/usr/local/lib/node_modules/hexo-cli'</span><span class="token punctuation">]</span><span class="token function">npm</span> ERR<span class="token operator">!</span>   errno: -13,<span class="token function">npm</span> ERR<span class="token operator">!</span>   code: <span class="token string">'EACCES'</span>,<span class="token function">npm</span> ERR<span class="token operator">!</span>   syscall: <span class="token string">'mkdir'</span>,<span class="token function">npm</span> ERR<span class="token operator">!</span>   path: <span class="token string">'/usr/local/lib/node_modules/hexo-cli'</span>,<span class="token function">npm</span> ERR<span class="token operator">!</span>   fstream_type: <span class="token string">'Directory'</span>,<span class="token function">npm</span> ERR<span class="token operator">!</span>   fstream_path: <span class="token string">'/usr/local/lib/node_modules/hexo-cli'</span>,<span class="token function">npm</span> ERR<span class="token operator">!</span>   fstream_class: <span class="token string">'DirWriter'</span>,<span class="token function">npm</span> ERR<span class="token operator">!</span>   fstream_stack:<span class="token function">npm</span> ERR<span class="token operator">!</span>    <span class="token punctuation">[</span> <span class="token string">'/usr/local/lib/node_modules/npm/node_modules/fstream/lib/dir-writer.js:35:25'</span>,<span class="token function">npm</span> ERR<span class="token operator">!</span>      <span class="token string">'/usr/local/lib/node_modules/npm/node_modules/mkdirp/index.js:47:53'</span>,<span class="token function">npm</span> ERR<span class="token operator">!</span>      <span class="token string">'FSReqWrap.oncomplete (fs.js:82:15)'</span> <span class="token punctuation">]</span> <span class="token punctuation">}</span><span class="token function">npm</span> ERR<span class="token operator">!</span><span class="token function">npm</span> ERR<span class="token operator">!</span> Please try running this <span class="token function">command</span> again as root/Administrator.</code></pre><p>询问度娘，采用另外一种安装方式，如下：</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">sudo</span> <span class="token function">npm</span> <span class="token function">install</span> --unsafe-perm --verbose -g hexo</code></pre><p>至此，Hexo本人尝试安装成功。</p><h2 id="Hexo使用"><a href="#Hexo使用" class="headerlink" title="Hexo使用"></a>Hexo使用</h2><p>终端切换到一个你准备用来搭建博客的目录，然后执行命令</p><pre class=" language-bash"><code class="language-bash">$ hexo init blog</code></pre><p>其中blog将会作为博客网站的本地主目录，该命令对文件夹进行了初始化，生成了一些建设网站所必须的材料。切换到myblog文件夹下，执行以下命令</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">npm</span> <span class="token function">install</span></code></pre><p>安装完成后，执行</p><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>出现如下即可说明搭建成功</p><pre class=" language-bash"><code class="language-bash">INFO  Start processingINFO  Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.</code></pre><p>复制<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 到浏览器就可以看到hexo默认配置的landscape主题的博客界面<br>再往后就是定制化，个性化修改你自己想要的风格了。</p><h3 id="修改配置信息"><a href="#修改配置信息" class="headerlink" title="修改配置信息"></a>修改配置信息</h3><h3 id="通过git发布"><a href="#通过git发布" class="headerlink" title="通过git发布"></a>通过git发布</h3><p>首先，我们要在github上新建一个Repository，名称固定为</p><pre class=" language-bash"><code class="language-bash">$ yourNickName.github.io</code></pre><p>其中yourNickName指的是你的github账户昵称，注意必须按照这个规则来命名。然后我们编辑myblog/_config.yml文件，在文件的最后几行找到deploy设置项，按照下面的方式进行修改</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># Deployment</span><span class="token comment" spellcheck="true">## Docs: https://hexo.io/docs/deployment.html</span>deploy:  type: <span class="token function">git</span>  repository: git@github.com:coolBoyGym/coolboygym.github.io.git  branch: master</code></pre><p>其中的repository字段需改成你自己的giuhub项目对应的地址。</p><p>修改完成后，在blog目录下依次运行以下命令（此命令本地修改后 push到git都需要执行）</p><pre class=" language-bash"><code class="language-bash">$ hexo generate$ hexo deploy</code></pre><p>Hexo会将所有文件推送到github上对应的项目中。然后访问一下地址：</p><p><a href="https://yourNickName.github.io" target="_blank" rel="noopener">https://yourNickName.github.io</a></p><p>即可查看你自己的博客啦</p><h2 id="修改背景图"><a href="#修改背景图" class="headerlink" title="修改背景图"></a>修改背景图</h2><pre class=" language-bash"><code class="language-bash">body <span class="token punctuation">{</span>    background:url<span class="token punctuation">(</span>https://source.unsplash.com/random/1600x900<span class="token punctuation">)</span><span class="token punctuation">;</span>    background-repeat: no-repeat<span class="token punctuation">;</span>    background-attachment:fixed<span class="token punctuation">;</span>    background-position:50% 50%<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>url可更换为自己喜欢的图片的地址。</p><p>repeat：是否重复出现</p><p>attachment：定义背景图片随滚动轴的移动方式</p><p>position：设置背景图像的起始位置。</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 博客 </tag>
            
            <tag> 搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS富文本-让你的label绚烂起来</title>
      <link href="/2018/11/13/iOS%E5%BC%80%E5%8F%91/iOS%E5%AF%8C%E6%96%87%E6%9C%AC/"/>
      <url>/2018/11/13/iOS%E5%BC%80%E5%8F%91/iOS%E5%AF%8C%E6%96%87%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<p>NSFontAttributeName                设置字体属性，默认值：字体：Helvetica(Neue) 字号：12<br>NSForegroundColorAttributeNam      设置字体颜色，取值为 UIColor对象，默认值为黑色<br>NSBackgroundColorAttributeName     设置字体所在区域背景颜色，取值为 UIColor对象，默认值为nil, 透明色<br>NSLigatureAttributeName            设置连体属性，取值为NSNumber 对象(整数)，0 表示没有连体字符，1 表示使用默认的连体字符<br>NSKernAttributeName                设定字符间距，取值为 NSNumber 对象（整数），正值间距加宽，负值间距变窄<br>NSStrikethroughStyleAttributeName  设置删除线，取值为 NSNumber 对象（整数）<br>NSStrikethroughColorAttributeName  设置删除线颜色，取值为 UIColor 对象，默认值为黑色<br>NSUnderlineStyleAttributeName      设置下划线，取值为 NSNumber 对象（整数），枚举常量 NSUnderlineStyle中的值，与删除线类似<br>NSUnderlineColorAttributeName      设置下划线颜色，取值为 UIColor 对象，默认值为黑色<br>NSStrokeWidthAttributeName         设置笔画宽度，取值为 NSNumber 对象（整数），负值填充效果，正值中空效果<br>NSStrokeColorAttributeName         填充部分颜色，不是字体颜色，取值为 UIColor 对象<br>NSShadowAttributeName              设置阴影属性，取值为 NSShadow 对象<br>NSTextEffectAttributeName          设置文本特殊效果，取值为 NSString 对象，目前只有图版印刷效果可用：<br>NSBaselineOffsetAttributeName      设置基线偏移值，取值为 NSNumber （float）,正值上偏，负值下偏<br>NSObliquenessAttributeName         设置字形倾斜度，取值为 NSNumber （float）,正值右倾，负值左倾<br>NSExpansionAttributeName           设置文本横向拉伸属性，取值为 NSNumber （float）,正值横向拉伸文本，负值横向压缩文本<br>NSWritingDirectionAttributeName    设置文字书写方向，从左向右书写或者从右向左书写<br>NSVerticalGlyphFormAttributeName   设置文字排版方向，取值为 NSNumber 对象(整数)，0 表示横排文本，1 表示竖排文本<br>NSLinkAttributeName                设置链接属性，点击后调用浏览器打开指定URL地址<br>NSAttachmentAttributeName          设置文本附件,取值为NSTextAttachment对象,常用于文字图片混排<br>NSParagraphStyleAttributeName      设置文本段落排版格式，取值为 NSParagraphStyle 对象</p><p>SDWebimage</p><p>Memory Disk</p><p>先从内存缓存查询 ,</p><p>查询到 &gt; 取出展示  </p><p>未查询到 &gt; 从磁盘缓存中获取</p><p>获取到 &gt; 设置到内存缓存 &gt; 取出展示</p><p>未获取到 &gt; 调用网络瞎子啊</p>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 富文本 </tag>
            
            <tag> 颜色、字体 </tag>
            
            <tag> 背景 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GCD的前世今生</title>
      <link href="/2018/10/17/iOS%E5%BC%80%E5%8F%91/GCD%E7%BA%BF%E7%A8%8B/"/>
      <url>/2018/10/17/iOS%E5%BC%80%E5%8F%91/GCD%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h2><p> 1、GCD全称 Grand Central Dispatch ，是纯C语言，提供了非常多强大的函数，来进行系统线程的管理。<br> 2、优势：GCD是苹果公司为多核的并行运算提出的解决方案。GCD会自动利用更多的CPU内核，会自动管理线程的生命周期（创建线程、调度任务、销毁线程），程序员只需要告诉GCD想要执行什么任务，不需要编写任何线程管理代码。</p><table><thead><tr><th></th><th>并发</th><th>串行</th><th>主队列</th></tr></thead><tbody><tr><td>同步(sync)</td><td>没有开启新线程 串行执行任务</td><td>没有开启新线程 串行执行</td><td>锁死</td></tr><tr><td>异步(async)</td><td>有开启新线程 并行执行</td><td>有开启新线程 串行执行</td><td>没开启新线程 串行执行</td></tr></tbody></table><p>串行 (DISPATCH_QUEUE_SERIAL)<br>并发 (DISPATCH_QUEUE_CONCURRENT)</p><h2 id="四种组合方式"><a href="#四种组合方式" class="headerlink" title="四种组合方式"></a>四种组合方式</h2><h3 id="同步执行-并发队列"><a href="#同步执行-并发队列" class="headerlink" title="同步执行 + 并发队列"></a>同步执行 + 并发队列</h3><pre class=" language-bash"><code class="language-bash">/** 同步 + 并发 在当前线程中执行任务，不会开启新线程，执行完一个任务，再执行下一个任务。 */- <span class="token punctuation">(</span>void<span class="token punctuation">)</span>synchronousAndConcurrent<span class="token punctuation">{</span>    NSLog<span class="token punctuation">(</span>@<span class="token string">"currentThread---%@"</span>,<span class="token punctuation">[</span>NSThread currentThread<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  // 打印当前线程    NSLog<span class="token punctuation">(</span>@<span class="token string">"synchronousAndConcurrent---begin"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> //线程开始    dispatch_queue_t queue <span class="token operator">=</span> dispatch_queue_create<span class="token punctuation">(</span><span class="token string">"com.leocy.gcd"</span>, DISPATCH_QUEUE_CONCURRENT<span class="token punctuation">)</span><span class="token punctuation">;</span>    dispatch_sync<span class="token punctuation">(</span>queue, ^<span class="token punctuation">{</span>        // 添加任务1        <span class="token keyword">for</span> <span class="token punctuation">(</span>int i <span class="token operator">=</span> 0<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> 2<span class="token punctuation">;</span> ++i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token punctuation">[</span>NSThread sleepForTimeInterval:2<span class="token punctuation">]</span><span class="token punctuation">;</span>              // 模拟耗时操作            NSLog<span class="token punctuation">(</span>@<span class="token string">"1---%@"</span>,<span class="token punctuation">[</span>NSThread currentThread<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      // 打印当前线程        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    dispatch_sync<span class="token punctuation">(</span>queue, ^<span class="token punctuation">{</span>        // 添加任务2        <span class="token keyword">for</span> <span class="token punctuation">(</span>int i <span class="token operator">=</span> 0<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> 2<span class="token punctuation">;</span> ++i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token punctuation">[</span>NSThread sleepForTimeInterval:2<span class="token punctuation">]</span><span class="token punctuation">;</span>              // 模拟耗时操作            NSLog<span class="token punctuation">(</span>@<span class="token string">"2---%@"</span>,<span class="token punctuation">[</span>NSThread currentThread<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      // 打印当前线程        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    dispatch_sync<span class="token punctuation">(</span>queue, ^<span class="token punctuation">{</span>        // 添加任务3        <span class="token keyword">for</span> <span class="token punctuation">(</span>int i <span class="token operator">=</span> 0<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> 2<span class="token punctuation">;</span> ++i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token punctuation">[</span>NSThread sleepForTimeInterval:2<span class="token punctuation">]</span><span class="token punctuation">;</span>              // 模拟耗时操作            NSLog<span class="token punctuation">(</span>@<span class="token string">"3---%@"</span>,<span class="token punctuation">[</span>NSThread currentThread<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      // 打印当前线程        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     NSLog<span class="token punctuation">(</span>@<span class="token string">"synchronousAndConcurrent---end"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> //线程结束<span class="token punctuation">}</span></code></pre><p>运行结果:<strong>没开启新线程，串行执行</strong></p><blockquote><p>2019-01-15 17:31:46.958190+0800 GCD使用[11901:3502931] currentThread—&lt;NSThread: 0x283c32e00&gt;{number = 1, name = main}<br>2019-01-15 17:31:46.958258+0800 GCD使用[11901:3502931] synchronousAndConcurrent—begin<br>2019-01-15 17:31:48.959827+0800 GCD使用[11901:3502931] 1—&lt;NSThread: 0x283c32e00&gt;{number = 1, name = main}<br>2019-01-15 17:31:50.961196+0800 GCD使用[11901:3502931] 1—&lt;NSThread: 0x283c32e00&gt;{number = 1, name = main}<br>2019-01-15 17:31:52.962809+0800 GCD使用[11901:3502931] 2—&lt;NSThread: 0x283c32e00&gt;{number = 1, name = main}<br>2019-01-15 17:31:54.963861+0800 GCD使用[11901:3502931] 2—&lt;NSThread: 0x283c32e00&gt;{number = 1, name = main}<br>2019-01-15 17:31:56.965229+0800 GCD使用[11901:3502931] 3—&lt;NSThread: 0x283c32e00&gt;{number = 1, name = main}<br>2019-01-15 17:31:58.966589+0800 GCD使用[11901:3502931] 3—&lt;NSThread: 0x283c32e00&gt;{number = 1, name = main}<br>2019-01-15 17:32:02.847758+0800 GCD使用[11901:3502931] synchronousAndConcurrent—end<br>(lldb) </p></blockquote><!--![](https://github.com/ReaperLC/Hello-World/blob/master/GCD/GCD%E4%BD%BF%E7%94%A8/Resource/%E5%90%8C%E6%AD%A5+%E5%B9%B6%E5%8F%91.png?raw=true)--><h3 id="异步执行-并发队列"><a href="#异步执行-并发队列" class="headerlink" title="异步执行 + 并发队列"></a>异步执行 + 并发队列</h3><pre class=" language-bash"><code class="language-bash">/** 异步 + 并发 可以开启多个线程，任务交替（同时）执行。 */- <span class="token punctuation">(</span>void<span class="token punctuation">)</span>asynchronousAndConcurrent<span class="token punctuation">{</span>    NSLog<span class="token punctuation">(</span>@<span class="token string">"currentThread---%@"</span>,<span class="token punctuation">[</span>NSThread currentThread<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  // 打印当前线程    NSLog<span class="token punctuation">(</span>@<span class="token string">"synchronousAndSerial---begin"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> //线程开始    dispatch_queue_t queue <span class="token operator">=</span> dispatch_queue_create<span class="token punctuation">(</span><span class="token string">"com.leocy.gcd"</span>, DISPATCH_QUEUE_CONCURRENT<span class="token punctuation">)</span><span class="token punctuation">;</span>    dispatch_async<span class="token punctuation">(</span>queue, ^<span class="token punctuation">{</span>        // 添加任务1        <span class="token keyword">for</span> <span class="token punctuation">(</span>int i <span class="token operator">=</span> 0<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> 2<span class="token punctuation">;</span> ++i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token punctuation">[</span>NSThread sleepForTimeInterval:2<span class="token punctuation">]</span><span class="token punctuation">;</span>              // 模拟耗时操作            NSLog<span class="token punctuation">(</span>@<span class="token string">"1---%@"</span>,<span class="token punctuation">[</span>NSThread currentThread<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      // 打印当前线程        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    dispatch_async<span class="token punctuation">(</span>queue, ^<span class="token punctuation">{</span>        // 添加任务2        <span class="token keyword">for</span> <span class="token punctuation">(</span>int i <span class="token operator">=</span> 0<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> 2<span class="token punctuation">;</span> ++i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token punctuation">[</span>NSThread sleepForTimeInterval:2<span class="token punctuation">]</span><span class="token punctuation">;</span>              // 模拟耗时操作            NSLog<span class="token punctuation">(</span>@<span class="token string">"2---%@"</span>,<span class="token punctuation">[</span>NSThread currentThread<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      // 打印当前线程        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    dispatch_async<span class="token punctuation">(</span>queue, ^<span class="token punctuation">{</span>        // 添加任务3        <span class="token keyword">for</span> <span class="token punctuation">(</span>int i <span class="token operator">=</span> 0<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> 2<span class="token punctuation">;</span> ++i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token punctuation">[</span>NSThread sleepForTimeInterval:2<span class="token punctuation">]</span><span class="token punctuation">;</span>              // 模拟耗时操作            NSLog<span class="token punctuation">(</span>@<span class="token string">"3---%@"</span>,<span class="token punctuation">[</span>NSThread currentThread<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      // 打印当前线程        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    NSLog<span class="token punctuation">(</span>@<span class="token string">"asynchronousAndConcurrent---end"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> //线程结束<span class="token punctuation">}</span></code></pre><p>执行结果:<strong>开启新线程，并发执行</strong></p><blockquote><p>2019-01-15 17:34:40.553187+0800 GCD使用[11912:3504396] currentThread—&lt;NSThread: 0x281dbee40&gt;{number = 1, name = main}<br>2019-01-15 17:34:40.553228+0800 GCD使用[11912:3504396] synchronousAndSerial—begin<br>2019-01-15 17:34:40.553262+0800 GCD使用[11912:3504396] asynchronousAndConcurrent—end<br>2019-01-15 17:34:44.382094+0800 GCD使用[11912:3504445] 3—&lt;NSThread: 0x281df02c0&gt;{number = 5, name = (null)}<br>2019-01-15 17:34:44.382096+0800 GCD使用[11912:3504446] 1—&lt;NSThread: 0x281dd4540&gt;{number = 4, name = (null)}<br>2019-01-15 17:34:44.382237+0800 GCD使用[11912:3504443] 2—&lt;NSThread: 0x281de2100&gt;{number = 3, name = (null)}<br>2019-01-15 17:34:46.385780+0800 GCD使用[11912:3504443] 2—&lt;NSThread: 0x281de2100&gt;{number = 3, name = (null)}<br>2019-01-15 17:34:46.385779+0800 GCD使用[11912:3504445] 3—&lt;NSThread: 0x281df02c0&gt;{number = 5, name = (null)}<br>2019-01-15 17:34:46.385779+0800 GCD使用[11912:3504446] 1—&lt;NSThread: 0x281dd4540&gt;{number = 4, name = (null)}</p></blockquote><!--![](https://github.com/ReaperLC/Hello-World/blob/master/GCD/GCD%E4%BD%BF%E7%94%A8/Resource/%E5%BC%82%E6%AD%A5+%E5%B9%B6%E5%8F%91.png?raw=true)--><h3 id="同步执行-串行队列"><a href="#同步执行-串行队列" class="headerlink" title="同步执行 + 串行队列"></a>同步执行 + 串行队列</h3><pre class=" language-bash"><code class="language-bash">/** 同步 + 串行 不会开启新线程，在当前线程执行任务。任务是串行的，执行完一个任务，再执行下一个任务。 */- <span class="token punctuation">(</span>void<span class="token punctuation">)</span>synchronousAndSerial<span class="token punctuation">{</span>    NSLog<span class="token punctuation">(</span>@<span class="token string">"currentThread---%@"</span>,<span class="token punctuation">[</span>NSThread currentThread<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  // 打印当前线程    NSLog<span class="token punctuation">(</span>@<span class="token string">"synchronousAndSerial---begin"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> //线程开始    dispatch_queue_t queue <span class="token operator">=</span> dispatch_queue_create<span class="token punctuation">(</span><span class="token string">"com.leocy.gcd"</span>, DISPATCH_QUEUE_SERIAL<span class="token punctuation">)</span><span class="token punctuation">;</span>    dispatch_sync<span class="token punctuation">(</span>queue, ^<span class="token punctuation">{</span>        // 添加任务1        <span class="token keyword">for</span> <span class="token punctuation">(</span>int i <span class="token operator">=</span> 0<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> 2<span class="token punctuation">;</span> ++i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token punctuation">[</span>NSThread sleepForTimeInterval:2<span class="token punctuation">]</span><span class="token punctuation">;</span>              // 模拟耗时操作            NSLog<span class="token punctuation">(</span>@<span class="token string">"1---%@"</span>,<span class="token punctuation">[</span>NSThread currentThread<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      // 打印当前线程        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    dispatch_sync<span class="token punctuation">(</span>queue, ^<span class="token punctuation">{</span>        // 添加任务2        <span class="token keyword">for</span> <span class="token punctuation">(</span>int i <span class="token operator">=</span> 0<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> 2<span class="token punctuation">;</span> ++i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token punctuation">[</span>NSThread sleepForTimeInterval:2<span class="token punctuation">]</span><span class="token punctuation">;</span>              // 模拟耗时操作            NSLog<span class="token punctuation">(</span>@<span class="token string">"2---%@"</span>,<span class="token punctuation">[</span>NSThread currentThread<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      // 打印当前线程        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    dispatch_sync<span class="token punctuation">(</span>queue, ^<span class="token punctuation">{</span>        // 添加任务3        <span class="token keyword">for</span> <span class="token punctuation">(</span>int i <span class="token operator">=</span> 0<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> 2<span class="token punctuation">;</span> ++i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token punctuation">[</span>NSThread sleepForTimeInterval:2<span class="token punctuation">]</span><span class="token punctuation">;</span>              // 模拟耗时操作            NSLog<span class="token punctuation">(</span>@<span class="token string">"3---%@"</span>,<span class="token punctuation">[</span>NSThread currentThread<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      // 打印当前线程        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    NSLog<span class="token punctuation">(</span>@<span class="token string">"synchronousAndSerial---end"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> //线程结束<span class="token punctuation">}</span></code></pre><p>执行结果:<strong>没开启新线程，串行执行</strong></p><blockquote><p>2019-01-15 17:33:37.132737+0800 GCD使用[11907:3503870] currentThread—&lt;NSThread: 0x2815e2e40&gt;{number = 1, name = main}<br>2019-01-15 17:33:37.132774+0800 GCD使用[11907:3503870] synchronousAndSerial—begin<br>2019-01-15 17:33:39.134268+0800 GCD使用[11907:3503870] 1—&lt;NSThread: 0x2815e2e40&gt;{number = 1, name = main}<br>2019-01-15 17:33:41.135846+0800 GCD使用[11907:3503870] 1—&lt;NSThread: 0x2815e2e40&gt;{number = 1, name = main}<br>2019-01-15 17:33:43.137197+0800 GCD使用[11907:3503870] 2—&lt;NSThread: 0x2815e2e40&gt;{number = 1, name = main}<br>2019-01-15 17:33:45.138594+0800 GCD使用[11907:3503870] 2—&lt;NSThread: 0x2815e2e40&gt;{number = 1, name = main}<br>2019-01-15 17:33:47.140036+0800 GCD使用[11907:3503870] 3—&lt;NSThread: 0x2815e2e40&gt;{number = 1, name = main}<br>2019-01-15 17:33:49.141438+0800 GCD使用[11907:3503870] 3—&lt;NSThread: 0x2815e2e40&gt;{number = 1, name = main}<br>2019-01-15 17:33:49.141599+0800 GCD使用[11907:3503870] synchronousAndSerial—end<br>(lldb)<br><!--![](https://github.com/ReaperLC/Hello-World/blob/master/GCD/GCD%E4%BD%BF%E7%94%A8/Resource/%E5%90%8C%E6%AD%A5%20+%20%E4%B8%B2%E8%A1%8C.png?raw=true)--></p></blockquote><h3 id="异步执行-串行队列"><a href="#异步执行-串行队列" class="headerlink" title="异步执行 + 串行队列"></a>异步执行 + 串行队列</h3><pre class=" language-bash"><code class="language-bash">/** 异步 + 串行 特点：会开启一条新线程，但是因为任务是串行的，执行完一个任务，再执行下一个任务。 */- <span class="token punctuation">(</span>void<span class="token punctuation">)</span>asynchronousAndSerial<span class="token punctuation">{</span>    NSLog<span class="token punctuation">(</span>@<span class="token string">"currentThread---%@"</span>,<span class="token punctuation">[</span>NSThread currentThread<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  // 打印当前线程    NSLog<span class="token punctuation">(</span>@<span class="token string">"synchronousAndSerial---begin"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> //线程开始    dispatch_queue_t queue <span class="token operator">=</span> dispatch_queue_create<span class="token punctuation">(</span><span class="token string">"com.leocy.gcd"</span>, DISPATCH_QUEUE_SERIAL<span class="token punctuation">)</span><span class="token punctuation">;</span>    dispatch_async<span class="token punctuation">(</span>queue, ^<span class="token punctuation">{</span>        // 添加任务1        <span class="token keyword">for</span> <span class="token punctuation">(</span>int i <span class="token operator">=</span> 0<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> 2<span class="token punctuation">;</span> ++i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token punctuation">[</span>NSThread sleepForTimeInterval:2<span class="token punctuation">]</span><span class="token punctuation">;</span>              // 模拟耗时操作            NSLog<span class="token punctuation">(</span>@<span class="token string">"1---%@"</span>,<span class="token punctuation">[</span>NSThread currentThread<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      // 打印当前线程        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    dispatch_async<span class="token punctuation">(</span>queue, ^<span class="token punctuation">{</span>        // 添加任务2        <span class="token keyword">for</span> <span class="token punctuation">(</span>int i <span class="token operator">=</span> 0<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> 2<span class="token punctuation">;</span> ++i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token punctuation">[</span>NSThread sleepForTimeInterval:2<span class="token punctuation">]</span><span class="token punctuation">;</span>              // 模拟耗时操作            NSLog<span class="token punctuation">(</span>@<span class="token string">"2---%@"</span>,<span class="token punctuation">[</span>NSThread currentThread<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      // 打印当前线程        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    dispatch_async<span class="token punctuation">(</span>queue, ^<span class="token punctuation">{</span>        // 添加任务3        <span class="token keyword">for</span> <span class="token punctuation">(</span>int i <span class="token operator">=</span> 0<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> 2<span class="token punctuation">;</span> ++i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token punctuation">[</span>NSThread sleepForTimeInterval:2<span class="token punctuation">]</span><span class="token punctuation">;</span>              // 模拟耗时操作            NSLog<span class="token punctuation">(</span>@<span class="token string">"3---%@"</span>,<span class="token punctuation">[</span>NSThread currentThread<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      // 打印当前线程        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     NSLog<span class="token punctuation">(</span>@<span class="token string">"synchronousAndSerial---end"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> //线程结束<span class="token punctuation">}</span></code></pre><p> 执行结果:<strong>开启一条新线程，串行执行</strong></p><blockquote><p>2019-01-15 17:35:35.597125+0800 GCD使用[11917:3504860] currentThread—&lt;NSThread: 0x281265b80&gt;{number = 1, name = main}<br>2019-01-15 17:35:35.597163+0800 GCD使用[11917:3504860] synchronousAndSerial—begin<br>2019-01-15 17:35:35.597196+0800 GCD使用[11917:3504860] synchronousAndSerial—end<br>2019-01-15 17:35:38.944090+0800 GCD使用[11917:3504894] 1—&lt;NSThread: 0x281207740&gt;{number = 4, name = (null)}<br>2019-01-15 17:35:40.949580+0800 GCD使用[11917:3504894] 1—&lt;NSThread: 0x281207740&gt;{number = 4, name = (null)}<br>2019-01-15 17:35:42.955068+0800 GCD使用[11917:3504894] 2—&lt;NSThread: 0x281207740&gt;{number = 4, name = (null)}<br>2019-01-15 17:35:44.960644+0800 GCD使用[11917:3504894] 2—&lt;NSThread: 0x281207740&gt;{number = 4, name = (null)}<br>2019-01-15 17:35:46.966089+0800 GCD使用[11917:3504894] 3—&lt;NSThread: 0x281207740&gt;{number = 4, name = (null)}<br>2019-01-15 17:35:48.971523+0800 GCD使用[11917:3504894] 3—&lt;NSThread: 0x281207740&gt;{number = 4, name = (null)}<br><!--![](https://github.com/ReaperLC/Hello-World/blob/master/GCD/GCD%E4%BD%BF%E7%94%A8/Resource/%E5%BC%82%E6%AD%A5%2B%20%E4%B8%B2%E8%A1%8C.png?raw=true)--></p></blockquote><h2 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h2><h3 id="同步执行-主队列"><a href="#同步执行-主队列" class="headerlink" title="同步执行 + 主队列"></a>同步执行 + 主队列</h3><pre class=" language-bash"><code class="language-bash">/** * 同步 + 主队列 * 特点<span class="token punctuation">(</span>主线程调用<span class="token punctuation">)</span>：互等卡主不执行。 * 特点<span class="token punctuation">(</span>其他线程调用<span class="token punctuation">)</span>：不会开启新线程，执行完一个任务，再执行下一个任务。 */- <span class="token punctuation">(</span>void<span class="token punctuation">)</span> synchronousAndMain <span class="token punctuation">{</span>    NSLog<span class="token punctuation">(</span>@<span class="token string">"currentThread---%@"</span>,<span class="token punctuation">[</span>NSThread currentThread<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  // 打印当前线程    NSLog<span class="token punctuation">(</span>@<span class="token string">"synchronousAndMain---begin"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    dispatch_queue_t mainQueue <span class="token operator">=</span> dispatch_get_main_queue<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>//    dispatch_queue_t mainQueue <span class="token operator">=</span> dispatch_queue_create<span class="token punctuation">(</span><span class="token string">"com.leocy.gcd"</span>, DISPATCH_QUEUE_SERIAL<span class="token punctuation">)</span><span class="token punctuation">;</span>    dispatch_sync<span class="token punctuation">(</span>mainQueue, ^<span class="token punctuation">{</span>        // 追加任务1        <span class="token keyword">for</span> <span class="token punctuation">(</span>int i <span class="token operator">=</span> 0<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> 2<span class="token punctuation">;</span> ++i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token punctuation">[</span>NSThread sleepForTimeInterval:2<span class="token punctuation">]</span><span class="token punctuation">;</span>              // 模拟耗时操作            NSLog<span class="token punctuation">(</span>@<span class="token string">"1---%@"</span>,<span class="token punctuation">[</span>NSThread currentThread<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      // 打印当前线程        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    dispatch_sync<span class="token punctuation">(</span>mainQueue, ^<span class="token punctuation">{</span>        // 追加任务2        <span class="token keyword">for</span> <span class="token punctuation">(</span>int i <span class="token operator">=</span> 0<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> 2<span class="token punctuation">;</span> ++i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token punctuation">[</span>NSThread sleepForTimeInterval:2<span class="token punctuation">]</span><span class="token punctuation">;</span>              // 模拟耗时操作            NSLog<span class="token punctuation">(</span>@<span class="token string">"2---%@"</span>,<span class="token punctuation">[</span>NSThread currentThread<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      // 打印当前线程        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    dispatch_sync<span class="token punctuation">(</span>mainQueue, ^<span class="token punctuation">{</span>        // 追加任务3        <span class="token keyword">for</span> <span class="token punctuation">(</span>int i <span class="token operator">=</span> 0<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> 2<span class="token punctuation">;</span> ++i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token punctuation">[</span>NSThread sleepForTimeInterval:2<span class="token punctuation">]</span><span class="token punctuation">;</span>              // 模拟耗时操作            NSLog<span class="token punctuation">(</span>@<span class="token string">"3---%@"</span>,<span class="token punctuation">[</span>NSThread currentThread<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      // 打印当前线程        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    NSLog<span class="token punctuation">(</span>@<span class="token string">"synchronousAndMain---end"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>执行结果:<strong>主线程调用：死锁卡住不执行 其他线程调用：没有开启新线程，串行执行任务</strong></p><h3 id="异步执行-主队列"><a href="#异步执行-主队列" class="headerlink" title="异步执行 + 主队列"></a>异步执行 + 主队列</h3><pre class=" language-bash"><code class="language-bash">/** 异步 +  主队列 */- <span class="token punctuation">(</span>void<span class="token punctuation">)</span>asynchrnousAndMain <span class="token punctuation">{</span>    NSLog<span class="token punctuation">(</span>@<span class="token string">"currentThread---%@"</span>,<span class="token punctuation">[</span>NSThread currentThread<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  // 打印当前线程    NSLog<span class="token punctuation">(</span>@<span class="token string">"asynchrnousAndMain---begin"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    dispatch_queue_t mainQueue <span class="token operator">=</span> dispatch_get_main_queue<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    dispatch_async<span class="token punctuation">(</span>mainQueue, ^<span class="token punctuation">{</span>        // 追加任务1        <span class="token keyword">for</span> <span class="token punctuation">(</span>int i <span class="token operator">=</span> 0<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> 2<span class="token punctuation">;</span> ++i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token punctuation">[</span>NSThread sleepForTimeInterval:2<span class="token punctuation">]</span><span class="token punctuation">;</span>              // 模拟耗时操作            NSLog<span class="token punctuation">(</span>@<span class="token string">"1---%@"</span>,<span class="token punctuation">[</span>NSThread currentThread<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      // 打印当前线程        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    dispatch_async<span class="token punctuation">(</span>mainQueue, ^<span class="token punctuation">{</span>        // 追加任务2        <span class="token keyword">for</span> <span class="token punctuation">(</span>int i <span class="token operator">=</span> 0<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> 2<span class="token punctuation">;</span> ++i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token punctuation">[</span>NSThread sleepForTimeInterval:2<span class="token punctuation">]</span><span class="token punctuation">;</span>              // 模拟耗时操作            NSLog<span class="token punctuation">(</span>@<span class="token string">"2---%@"</span>,<span class="token punctuation">[</span>NSThread currentThread<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      // 打印当前线程        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    dispatch_async<span class="token punctuation">(</span>mainQueue, ^<span class="token punctuation">{</span>        // 追加任务3        <span class="token keyword">for</span> <span class="token punctuation">(</span>int i <span class="token operator">=</span> 0<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> 2<span class="token punctuation">;</span> ++i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token punctuation">[</span>NSThread sleepForTimeInterval:2<span class="token punctuation">]</span><span class="token punctuation">;</span>              // 模拟耗时操作            NSLog<span class="token punctuation">(</span>@<span class="token string">"3---%@"</span>,<span class="token punctuation">[</span>NSThread currentThread<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      // 打印当前线程        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    NSLog<span class="token punctuation">(</span>@<span class="token string">"asynchrnousAndMain---end"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>执行结果:<strong>没开启新线程，串行执行</strong></p><blockquote><p>2019-01-15 17:39:53.716154+0800 GCD使用[11927:3506203] currentThread—&lt;NSThread: 0x283c02e40&gt;{number = 1, name = main}<br>2019-01-15 17:39:53.716196+0800 GCD使用[11927:3506203] asynchrnousAndMain—begin<br>2019-01-15 17:39:53.716226+0800 GCD使用[11927:3506203] asynchrnousAndMain—end<br>2019-01-15 17:39:57.868912+0800 GCD使用[11927:3506203] 1—&lt;NSThread: 0x283c02e40&gt;{number = 1, name = main}<br>2019-01-15 17:39:59.870304+0800 GCD使用[11927:3506203] 1—&lt;NSThread: 0x283c02e40&gt;{number = 1, name = main}<br>2019-01-15 17:40:01.871099+0800 GCD使用[11927:3506203] 2—&lt;NSThread: 0x283c02e40&gt;{number = 1, name = main}<br>2019-01-15 17:40:03.872303+0800 GCD使用[11927:3506203] 2—&lt;NSThread: 0x283c02e40&gt;{number = 1, name = main}<br>2019-01-15 17:40:05.873882+0800 GCD使用[11927:3506203] 3—&lt;NSThread: 0x283c02e40&gt;{number = 1, name = main}<br>2019-01-15 17:40:07.875393+0800 GCD使用[11927:3506203] 3—&lt;NSThread: 0x283c02e40&gt;{number = 1, name = main}</p></blockquote><h2 id="其他常用"><a href="#其他常用" class="headerlink" title="其他常用"></a>其他常用</h2><h3 id="栅栏-dispatch-barrier-async"><a href="#栅栏-dispatch-barrier-async" class="headerlink" title="栅栏  dispatch_barrier_async"></a>栅栏  dispatch_barrier_async</h3><pre class=" language-bash"><code class="language-bash">dispatch_barrier_sync<span class="token punctuation">(</span>queue, ^<span class="token punctuation">{</span>        NSLog<span class="token punctuation">(</span>@<span class="token string">"========栅栏========="</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>效果:<strong>栅栏上的上方的先执行,下方的待上方执行完毕后执行</strong></p><h3 id="延时-dispatch-after"><a href="#延时-dispatch-after" class="headerlink" title="延时  dispatch_after"></a>延时  dispatch_after</h3><pre class=" language-bash"><code class="language-bash">dispatch_after<span class="token punctuation">(</span>dispatch_time<span class="token punctuation">(</span>DISPATCH_TIME_NOW, <span class="token punctuation">(</span>int64_t<span class="token punctuation">)</span><span class="token punctuation">(</span>5.0 * NSEC_PER_SEC<span class="token punctuation">))</span>, dispatch_get_main_queue<span class="token punctuation">(</span><span class="token punctuation">)</span>, ^<span class="token punctuation">{</span>        // 5.0秒后异步追加任务代码到主队列，并开始执行        NSLog<span class="token punctuation">(</span>@<span class="token string">"after---%@"</span>,<span class="token punctuation">[</span>NSThread currentThread<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  // 打印当前线程<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="一次-dispatch-once-（单例）"><a href="#一次-dispatch-once-（单例）" class="headerlink" title="一次  dispatch_once  （单例）"></a>一次  dispatch_once  （单例）</h3><pre class=" language-bash"><code class="language-bash">static dispatch_once_t onceToken<span class="token punctuation">;</span>dispatch_once<span class="token punctuation">(</span><span class="token operator">&amp;</span>onceToken, ^<span class="token punctuation">{</span>        <span class="token operator">&lt;</span><span class="token comment" spellcheck="true">#code to be executed once#></span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="对列组-dispatch-group"><a href="#对列组-dispatch-group" class="headerlink" title="对列组 dispatch_group"></a>对列组 dispatch_group</h3><pre class=" language-bash"><code class="language-bash">/** * 队列组 dispatch_group_notify */- <span class="token punctuation">(</span>void<span class="token punctuation">)</span>groupNotify <span class="token punctuation">{</span>    NSLog<span class="token punctuation">(</span>@<span class="token string">"currentThread---%@"</span>,<span class="token punctuation">[</span>NSThread currentThread<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  // 打印当前线程    NSLog<span class="token punctuation">(</span>@<span class="token string">"group---begin"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    dispatch_group_t group <span class="token operator">=</span>  dispatch_group_create<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    dispatch_group_async<span class="token punctuation">(</span>group, dispatch_get_global_queue<span class="token punctuation">(</span>DISPATCH_QUEUE_PRIORITY_DEFAULT, 0<span class="token punctuation">)</span>, ^<span class="token punctuation">{</span>        // 追加任务1        <span class="token keyword">for</span> <span class="token punctuation">(</span>int i <span class="token operator">=</span> 0<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> 2<span class="token punctuation">;</span> ++i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token punctuation">[</span>NSThread sleepForTimeInterval:2<span class="token punctuation">]</span><span class="token punctuation">;</span>              // 模拟耗时操作            NSLog<span class="token punctuation">(</span>@<span class="token string">"1---%@"</span>,<span class="token punctuation">[</span>NSThread currentThread<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      // 打印当前线程        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    dispatch_group_async<span class="token punctuation">(</span>group, dispatch_get_global_queue<span class="token punctuation">(</span>DISPATCH_QUEUE_PRIORITY_DEFAULT, 0<span class="token punctuation">)</span>, ^<span class="token punctuation">{</span>        // 追加任务2        <span class="token keyword">for</span> <span class="token punctuation">(</span>int i <span class="token operator">=</span> 0<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> 2<span class="token punctuation">;</span> ++i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token punctuation">[</span>NSThread sleepForTimeInterval:2<span class="token punctuation">]</span><span class="token punctuation">;</span>              // 模拟耗时操作            NSLog<span class="token punctuation">(</span>@<span class="token string">"2---%@"</span>,<span class="token punctuation">[</span>NSThread currentThread<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      // 打印当前线程        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    dispatch_group_notify<span class="token punctuation">(</span>group, dispatch_get_main_queue<span class="token punctuation">(</span><span class="token punctuation">)</span>, ^<span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>int i <span class="token operator">=</span> 0<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> 2<span class="token punctuation">;</span> ++i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token punctuation">[</span>NSThread sleepForTimeInterval:2<span class="token punctuation">]</span><span class="token punctuation">;</span>              // 模拟耗时操作            NSLog<span class="token punctuation">(</span>@<span class="token string">"3---%@"</span>,<span class="token punctuation">[</span>NSThread currentThread<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      // 打印当前线程        <span class="token punctuation">}</span>        NSLog<span class="token punctuation">(</span>@<span class="token string">"group---end"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>执行结果:<strong>等前面的异步任务1、任务2都执行完毕后，回到主线程执行下边任务</strong></p><blockquote><p>2019-01-15 18:09:51.686244+0800 GCD使用[11955:3516270] currentThread—&lt;NSThread: 0x2831871c0&gt;{number = 1, name = main}<br>2019-01-15 18:09:51.686295+0800 GCD使用[11955:3516270] group—begin<br>2019-01-15 18:09:55.980170+0800 GCD使用[11955:3516409] 2—&lt;NSThread: 0x283186380&gt;{number = 5, name = (null)}<br>2019-01-15 18:09:55.980168+0800 GCD使用[11955:3516410] 1—&lt;NSThread: 0x2831a8380&gt;{number = 4, name = (null)}<br>2019-01-15 18:09:57.985010+0800 GCD使用[11955:3516410] 1—&lt;NSThread: 0x2831a8380&gt;{number = 4, name = (null)}<br>2019-01-15 18:09:57.985670+0800 GCD使用[11955:3516409] 2—&lt;NSThread: 0x283186380&gt;{number = 5, name = (null)}<br>2019-01-15 18:09:59.987117+0800 GCD使用[11955:3516270] 3—&lt;NSThread: 0x2831871c0&gt;{number = 1, name = main}<br>2019-01-15 18:10:01.988533+0800 GCD使用[11955:3516270] 3—&lt;NSThread: 0x2831871c0&gt;{number = 1, name = main}<br>2019-01-15 18:10:01.988660+0800 GCD使用[11955:3516270] group—end</p></blockquote><h3 id="监听-dispatch-group-notify"><a href="#监听-dispatch-group-notify" class="headerlink" title="监听  dispatch_group_notify"></a>监听  dispatch_group_notify</h3><h3 id="阻塞线程-dispatch-group-wait"><a href="#阻塞线程-dispatch-group-wait" class="headerlink" title="阻塞线程 dispatch_group_wait"></a>阻塞线程 dispatch_group_wait</h3>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Weakself 与 Strongself的兄弟情</title>
      <link href="/2018/10/16/iOS%E5%BC%80%E5%8F%91/WeakSelf%E4%B8%8EStrongSelf/"/>
      <url>/2018/10/16/iOS%E5%BC%80%E5%8F%91/WeakSelf%E4%B8%8EStrongSelf/</url>
      
        <content type="html"><![CDATA[<h2 id="Weakself-与-Strongself"><a href="#Weakself-与-Strongself" class="headerlink" title="Weakself 与 Strongself"></a>Weakself 与 Strongself</h2><p>1、什么时候用weakself?</p><p>主要看block是否被self持有，并且有没有产生循环引用 ，倘若都没有就不需要用weakself</p><p>2、什么时候用strongself?</p><p>主要是防止block执行过程中 self提前被释放导致出现奇怪的逻辑甚至是crash</p><p>总结来说，解决循环引用问题主要有两个办法：</p><p>防止循环引用</p><p>第一个办法是「事前避免」，我们在会产生循环引用的地方使用 weak 弱引用，以避免产生循环引用。<br>第二个办法是「事后补救」，我们明确知道会存在循环引用，但是我们在合理的位置主动断开环中的一个引用，使得对象得以回收。</p>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> self </tag>
            
            <tag> weakself </tag>
            
            <tag> Strongself </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS中的图片自适应拉伸</title>
      <link href="/2018/10/16/iOS%E5%BC%80%E5%8F%91/iOS%E4%B8%AD%E5%9B%BE%E7%89%87%E7%9A%84%E8%87%AA%E9%80%82%E5%BA%94%E6%8B%89%E4%BC%B8/"/>
      <url>/2018/10/16/iOS%E5%BC%80%E5%8F%91/iOS%E4%B8%AD%E5%9B%BE%E7%89%87%E7%9A%84%E8%87%AA%E9%80%82%E5%BA%94%E6%8B%89%E4%BC%B8/</url>
      
        <content type="html"><![CDATA[<h2 id="iOS中的图片自适应拉伸"><a href="#iOS中的图片自适应拉伸" class="headerlink" title="iOS中的图片自适应拉伸"></a>iOS中的图片自适应拉伸</h2><h3 id="iOS5之前"><a href="#iOS5之前" class="headerlink" title="iOS5之前"></a>iOS5之前</h3><pre class=" language-bash"><code class="language-bash">- <span class="token punctuation">(</span>UIImage *<span class="token punctuation">)</span>stretchableImageWithLeftCapWidth:<span class="token punctuation">(</span>NSInteger<span class="token punctuation">)</span>leftCapWidth topCapHeight:<span class="token punctuation">(</span>NSInteger<span class="token punctuation">)</span>topCapHeight<span class="token punctuation">;</span>  </code></pre><h3 id="iOS5"><a href="#iOS5" class="headerlink" title="iOS5"></a>iOS5</h3><pre class=" language-bash"><code class="language-bash">- <span class="token punctuation">(</span>UIImage *<span class="token punctuation">)</span>resizableImageWithCapInsets:<span class="token punctuation">(</span>UIEdgeInsets<span class="token punctuation">)</span>capInsets；</code></pre><h3 id="iOS6"><a href="#iOS6" class="headerlink" title="iOS6"></a>iOS6</h3><pre class=" language-bash"><code class="language-bash">- <span class="token punctuation">(</span>UIImage *<span class="token punctuation">)</span>resizableImageWithCapInsets:<span class="token punctuation">(</span>UIEdgeInsets<span class="token punctuation">)</span>capInsets resizingMode:<span class="token punctuation">(</span>UIImageResizingMode<span class="token punctuation">)</span>resizingMode；s</code></pre>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>iOS调试技巧大全</title>
      <link href="/2018/09/14/iOS%E5%BC%80%E5%8F%91/iOS%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/"/>
      <url>/2018/09/14/iOS%E5%BC%80%E5%8F%91/iOS%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<p><img src="https://images-cdn.shimo.im/Z480axvu1FgK6Voq/%E4%B8%8B%E8%BD%BD.png!thumbnail" alt=""></p><h2 id="NSLog"><a href="#NSLog" class="headerlink" title="NSLog"></a>NSLog</h2><pre class=" language-bash"><code class="language-bash">//保证 ifdef 中的宏定义只会在 OC 代码中被引用<span class="token punctuation">;</span>//否则一旦引入 C 或者 C++ 代码或者框架就会出错<span class="token operator">!</span><span class="token comment" spellcheck="true">#ifdef __OBJC__</span>//只在开发中用:<span class="token comment" spellcheck="true">#ifdef DEBUG</span>//定义 NSLog<span class="token punctuation">(</span>__VA_AGRS__<span class="token punctuation">)</span>://<span class="token comment" spellcheck="true">#define NSLog(...)  NSLog(__VA_ARGS__)</span><span class="token comment" spellcheck="true">#define NSLog(fmt, ...) NSLog((@"%s [Line %d]" fmt), __PRETTY_FUNCTION__, __LINE__, ##__VA_ARGS__)</span>//如果在非 DEBUG 情况下:<span class="token comment" spellcheck="true">#else</span>//NSLog<span class="token punctuation">(</span><span class="token punctuation">..</span>.<span class="token punctuation">)</span>后面不跟任何内容,在非 DEBUG 情况下<span class="token punctuation">(</span>提交上线发布时<span class="token punctuation">)</span>该 NSLog<span class="token punctuation">(</span><span class="token punctuation">..</span>.<span class="token punctuation">)</span>自动失效<span class="token operator">!</span><span class="token comment" spellcheck="true">#define NSLog(...)</span>//结束<span class="token string">"ifdef DEBUG"</span>,有 以 ifdef 开始就要有 endif 结束<span class="token operator">!</span>就酱<span class="token operator">!</span><span class="token comment" spellcheck="true">#endif</span>//结束<span class="token string">"ifdef __OBJC__"</span>,有 以 ifdef 开始就要有 endif 结束<span class="token operator">!</span>就酱<span class="token operator">!</span><span class="token comment" spellcheck="true">#endif</span></code></pre><p>控制台打印结果如下：</p><p><img src="https://images-cdn.shimo.im/Uf0XLUvibq4sU5vD/%E6%89%93%E5%8D%B0%E6%95%B0%E6%8D%AE.png!thumbnail" alt=""></p><h2 id="断点调试"><a href="#断点调试" class="headerlink" title="断点调试"></a>断点调试</h2><h3 id="普通断点"><a href="#普通断点" class="headerlink" title="普通断点"></a>普通断点</h3><p>1、快捷键添加方式 光标移动到需要断点的代码处： command + \<br>2、代码行旁边点击添加</p><p><img src="https://images-cdn.shimo.im/PiYSJXQH0dkvytqj/bug.png!thumbnail" alt=""></p><p>再点击取消断点</p><p><img src="https://images-cdn.shimo.im/FgAiNXkHnuQs8845/bug1.png!thumbnail" alt=""></p><h3 id="条件断点"><a href="#条件断点" class="headerlink" title="条件断点"></a>条件断点</h3><p>以上的断点只是最普通的，我们还能对断点的属性进行配置，设置条件，使断点更加智能化，右键断点进入编辑对话框：</p><p>1、右键断点，选择 Edit Breakpoint…</p><p><img src="https://images-cdn.shimo.im/xRZQFRR8WZg9yXBB/tianjia.png!thumbnail" alt=""></p><p>2、添加条件语句，此处OC怎么判断，条件语句就怎么写</p><p><img src="https://images-cdn.shimo.im/DzEjRIUO6F0ET11E/%E6%9D%A1%E4%BB%B6%E6%96%AD%E7%82%B9.png!thumbnail" alt=""></p><p>如上截图的这个例子，此断点如果不添加条件，循环中的代码每次都要单步执行，但是加了如下的条件：</p><pre><code>[str isEqualToString:@"5"]</code></pre><p>遍历前4位元素的时候是会顺利执行，不会断点的，当遍历到第5位，满足条件，中断程序，进行调试。</p><p>3、添加ignore条件，忽略前n次的执行</p><p><img src="https://images-cdn.shimo.im/uFhTWsGYDHwO58lc/ignor.png!thumbnail" alt=""></p><p> 如上图 ，4次之后才会单步执行后面的遍历，前4次是不会终止程序的。</p><p>4、查看函数调用次数</p><p><img src="https://images-cdn.shimo.im/mhoOaSpVmusxQR0F/%E6%AC%A1%E6%95%B0.png!thumbnail" alt=""></p><h2 id="异常断点"><a href="#异常断点" class="headerlink" title="异常断点"></a>异常断点</h2><p>断点的功能不限于上面所述,实际开发过程中，经常会遇见崩溃直接走到main函数，此时异常断点就派上用场了，点击 + 号选择 Exception Breakpoint…</p><p><img src="https://images-cdn.shimo.im/VMJXnPvIiispSceB/break.png!thumbnail" alt=""></p><p>如下即可，编辑断点，也还有相关详细设置，此处不做赘述</p><p><img src="https://images-cdn.shimo.im/3R6fTXmtxwIwsUck/yichang.png!thumbnail" alt=""></p><h2 id="符号断点"><a href="#符号断点" class="headerlink" title="符号断点"></a>符号断点</h2><p>符号断点创建同于异常断点，只不过点击 +  选择 Symbolic Breakpoint…即可<br>一般符号断点可以在你指定的[类名 方法名]时中断执行。比如指定</p><pre><code>[ViewController viewDidLoad]</code></pre><p><img src="https://images-cdn.shimo.im/dIYL0DLRumQfbB5x/fuhao.png!thumbnail" alt=""></p><p>那么程序在执行到viewDidLoad都会断点调试。</p><p>假如Symbol处只添加了一个方法名如下：</p><p><img src="https://images-cdn.shimo.im/9ypANLnnpxon2JfL/dosomething.png!thumbnail" alt=""></p><p>那么程序会执行到doSomething这个方法时断点调试，如下：</p><p><img src="https://images-cdn.shimo.im/491kCRts9sUei5wX/do.png!thumbnail" alt=""></p><h2 id="Console-LLDB命令"><a href="#Console-LLDB命令" class="headerlink" title="Console(LLDB命令)"></a>Console(LLDB命令)</h2><p> LLDB 绑定在 Xcode 内部，存在于主窗口底部的控制台中。<a href="http://lldb.llvm.org/lldb-gdb.html" target="_blank" rel="noopener">http://lldb.llvm.org/lldb-gdb.html</a> 这里是一份lldb命令清单，列出了lldb可用的命令。</p><p>常用的help命令，它会帮你罗列处命令列表供你选择</p><h3 id="help"><a href="#help" class="headerlink" title="help"></a><pre><code>help</code></pre></h3><p> 罗列出的所有方法中呢，就挑最常用的几种，比如：po/p/expression等，下面详细描述下：</p><p> <img src="https://images-cdn.shimo.im/wCTIyZBzkkUern0g/hellp.png!thumbnail" alt="">  </p><h3 id="print-obj"><a href="#print-obj" class="headerlink" title="print obj"></a><pre><code>print obj</code></pre></h3><p>   使用中用 p 代替即可，很明显这个是个打印命令</p><p>   <img src="https://images-cdn.shimo.im/D09mVI0vlbY4ZRKL/p.png!thumbnail" alt=""></p><h3 id="expression-obj"><a href="#expression-obj" class="headerlink" title="expression obj"></a><pre><code>expression obj</code></pre></h3><p>  改变程序实际参数的值，目的是方便了调试：不用重新运行项目</p><p>  <img src="https://images-cdn.shimo.im/c9SRcofiYsAVRGdD/expression.png!thumbnail" alt=""></p><p>  比如上面截图中的数组arr初始化数据为@[@”1”,@”2”,@”3”,@”4”,@”5”,@”6”,@”7”,@”8”];通过expression 修改元素为打印出来的结果。</p><h3 id="po-obj"><a href="#po-obj" class="headerlink" title="po obj"></a><pre><code>po obj</code></pre></h3><p>   平时用的比较多的“po”，它是“print object”的简写，po一下可以看到对象的详细信息</p><p>  <img src="https://images-cdn.shimo.im/QjzSfGUnZWgpTskk/po.png!thumbnail" alt=""></p><h3 id="call-obj"><a href="#call-obj" class="headerlink" title="call obj"></a><pre><code>call obj</code></pre></h3><p>   调用的意思，可以控制台调用函数或者方法 动态改变</p><pre class=" language-bash"><code class="language-bash">call  <span class="token punctuation">[</span>self.view setBackgroundColor:<span class="token punctuation">[</span>UIColor redColor<span class="token punctuation">]</span><span class="token punctuation">]</span></code></pre><p>   可以重设当前View背景色 无需重新运行</p><p>   或者调用程序里自己定义的函数方法</p><pre class=" language-bash"><code class="language-bash">call  <span class="token punctuation">[</span>self doSomething<span class="token punctuation">]</span></code></pre><p>   <img src="https://images-cdn.shimo.im/IOptiQU3BdMeFoOx/call.png!thumbnail" alt=""></p><p>   可见虽然函数还未运行，但是call命令却是可以提前调用的。</p><h2 id="NSZoombieEnabled"><a href="#NSZoombieEnabled" class="headerlink" title="NSZoombieEnabled"></a>NSZoombieEnabled</h2><p>僵尸对象调试开启：</p><p><img src="https://images-cdn.shimo.im/znk7s1gFIPIVBoH1/%E5%83%B5%E5%B0%B8%E5%AF%B9%E8%B1%A1.png!thumbnail" alt=""></p><h2 id="视图调试"><a href="#视图调试" class="headerlink" title="视图调试"></a>视图调试</h2><h3 id="View-Debug（Xcode6往后）"><a href="#View-Debug（Xcode6往后）" class="headerlink" title="View Debug（Xcode6往后）"></a>View Debug（Xcode6往后）</h3><p>Xcode6以后，苹果就已经推出了Debug View Hierarchy,也就是 视图层级调试， Xcode6之前还得去找第三方软件去查看视图层级</p><p><img src="https://images-cdn.shimo.im/77IIQB48k90E1yEt/viewdebug.png!thumbnail" alt=""></p><h3 id="po-打印视图层级"><a href="#po-打印视图层级" class="headerlink" title="po 打印视图层级"></a>po 打印视图层级</h3><h3 id="po-view-rescursiveDescription"><a href="#po-view-rescursiveDescription" class="headerlink" title="po [view rescursiveDescription]"></a><pre><code>po [view rescursiveDescription]</code></pre></h3><p><img src="https://images-cdn.shimo.im/toZVqt6hPog9YYxs/po_view.png!thumbnail" alt=""></p><p>由上打印结果也能看出当前视图层级，只是没有View Debug来的直观</p><h4 id="po-UIApplication-sharedApplication-keyWindow-recursiveDescription"><a href="#po-UIApplication-sharedApplication-keyWindow-recursiveDescription" class="headerlink" title="po [[[UIApplication sharedApplication] keyWindow] recursiveDescription]"></a><pre><code>po [[[UIApplication sharedApplication] keyWindow] recursiveDescription]</code></pre></h4><p>上面这段无需打断点 ，只要暂停，然后就可以输出当前窗口上的层级树。</p><h3 id="Reveal"><a href="#Reveal" class="headerlink" title="Reveal"></a>Reveal</h3><p>第三方 视图层级查看软件， </p><h2 id="Analyze静态分析"><a href="#Analyze静态分析" class="headerlink" title="Analyze静态分析"></a>Analyze静态分析</h2><p>静态分析工具 Product-&gt;Analyze(快捷键command+shift+B)可以找出代码潜在错误,如内存泄露,未使用函数和变量,循环引用等，但是友情提醒一句： <strong>Analyze静态分析不可全信，但也不能不信。</strong></p><p>Analyze主要的作用有：</p><ul><li>本地化问题 Localizability Issue (Apple)</li><li>声明错误检查（Dead store）</li><li>内存泄露检查 Memory Error</li><li>逻辑错误检查 Logic Error</li><li>API调用错误检查 API Misuse</li></ul><p><img src="https://images-cdn.shimo.im/ZQXabstnf1UWhlL8/analyze.png!thumbnail" alt=""></p><p>通过镜头分析，最后的结果会分门别类的列好如下图：</p><p><img src="https://images-cdn.shimo.im/gkZQpTMgozoBK6eG/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90.png!thumbnail" alt=""></p><h3 id="本地化问题"><a href="#本地化问题" class="headerlink" title="本地化问题"></a>本地化问题</h3><p>诸如此类，提示 User-facing text should use localized string macro…,  意思是面向用户的文本应该使用本地化的字符串宏.</p><p><img src="https://images-cdn.shimo.im/I5aWSPm9wjMSDudk/%E6%9C%AC%E5%9C%B0%E5%8C%96.png!thumbnail" alt=""></p><p>这种情况一般是因为代码中配置了本地化,面向用户的应该用字符串宏,而我们直接赋值为汉字.如下：</p><p><img src="https://images-cdn.shimo.im/yStYvFBnV3UETWDV/local.png!thumbnail" alt=""></p><p>所以解决方法：<br>1、直接将此处配置关闭，设置为NO<br>2、将项目中直接赋值的文本提出来，本地化</p><h3 id="声明错误检查"><a href="#声明错误检查" class="headerlink" title="声明错误检查"></a>声明错误检查</h3><p>无效数据如：Unused、Never read…. ，大致是那一类创建了但从未使用的变量</p><p><img src="https://images-cdn.shimo.im/zJDdDSVF0L0HAwm0/unuser.png!thumbnail" alt=""></p><p>一般情况删除这些变量即可</p><h3 id="内存泄露检查"><a href="#内存泄露检查" class="headerlink" title="内存泄露检查"></a>内存泄露检查</h3><p>1、一般来说都是由于使用的CoreFoundation后没有release造成的。 在RAC下Foundation框架下的不需要进行release，由于Core Foundation不在ARC管理范围内,所以需要主动release。</p><p>2、另外一些就是需要返回非空，却return nil;<br>3、空引用</p><h2 id="instruments动态分析"><a href="#instruments动态分析" class="headerlink" title="instruments动态分析"></a>instruments动态分析</h2>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LLDB </tag>
            
            <tag> NSLog </tag>
            
            <tag> 断点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>断•舍•离</title>
      <link href="/2018/08/07/%E5%85%B6%E4%BB%96/%E7%A2%8E/"/>
      <url>/2018/08/07/%E5%85%B6%E4%BB%96/%E7%A2%8E/</url>
      
        <content type="html"><![CDATA[<p>烟火  村口  小孩  期盼</p><p>月圆  门口  背影  希望</p><p>毅然远行 </p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>iOS音视频开发</title>
      <link href="/2018/08/06/iOS%E5%BC%80%E5%8F%91/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
      <url>/2018/08/06/iOS%E5%BC%80%E5%8F%91/%E9%9F%B3%E8%A7%86%E9%A2%91/</url>
      
        <content type="html"><![CDATA[<h1 id="Audio"><a href="#Audio" class="headerlink" title="Audio"></a>Audio</h1><h4 id="1、iOS-框架"><a href="#1、iOS-框架" class="headerlink" title="1、iOS 框架"></a>1、iOS 框架</h4><p>MediaPlayer 、 AudioToolbox 、 AudioUnit 、 AVFoundation 、 AVKit 、 OpenAL。其中MediaPlayer 、 AVFoundation 是基于 Objective-C/Swift 的； AudioToolBox 、 AudioUnit 和 OpenAL 是基于 C 的。</p><h4 id="2、第三方库"><a href="#2、第三方库" class="headerlink" title="2、第三方库"></a>2、第三方库</h4><p>FFmpeg 、 FAAC 、 FAAD2。</p><p>使用 MediaPlayer 框架的 MPMusicPlayerController 播放音频文件。<br>使用 AudioToolbox 框架的 System Sound Services 播放音频文件、 Audio Queue Services 录制和播放音频数据、 Audio Converter Services 进行音频转码(格式、 bit-depth 和采样率)、 Audio File Services 和 AudioFileStream 读写音频文件。<br>使用 AudioUnit 框架进行回音消除、音频数据录制和播放等。<br>使用 AVFoundation 框架的 AVAudioSession 操作音频会话、 AVAudioFile(iOS8) 读写音频文件、 AVAudioRecorder 录制音频文件、 AVAudioPlayer 和 AVPlayer 播放音频文件、 AVCaptureSession 录制音频和视频数据。<br>在 iOS 8 之前使用 AVFoundation 框架的 AVAssetWritter 将 PCM 音频写入 AAC LC 编码格式的音频文件，而且使用的是硬编码。<br>在 iOS 8 及以后可以使用 AVFoundation 框架的 AVAudioEngine 进行均衡器、混响和混音等操作，其基于底层的 AudioUnit ，但比后者更易用。<br>在 iOS 8 及以后可以使用 AVKit 框架的 AVPlayerController 播放音频文件或流。<br>使用 FAAC 将 PCM 软编码为 AAC LC。<br>使用 FFmpeg 或 FAAD2 将 AAC LC 软解码为 PCM 、 PCM 重采样(Resample)。</p><h1 id="Video"><a href="#Video" class="headerlink" title="Video"></a>Video</h1><h4 id="1、iOS-框架-1"><a href="#1、iOS-框架-1" class="headerlink" title="1、iOS 框架"></a>1、iOS 框架</h4><p>UIKit 、 MediaPlayer 、 AVFoundation 、 AVKit 、 VideoToolBox 、 GLKit(OpenGL ES) 。其中 UIKit 、 MediaPlayer 、 AVFoundation 和 AVKit 基于 Objective-C ； VideoToolBox 和 GLKit 基于 C 的。当然， GLKit 远远不只是可以渲染视频。</p><h4 id="2、第三方库-1"><a href="#2、第三方库-1" class="headerlink" title="2、第三方库"></a>2、第三方库</h4><p>FFmpeg 、 x264。</p><p>使用 UIKit 框架的 UIImagePickerController 录制包含音频的视频文件、 UIVideoEditorController 可对视频进行简单编辑。<br>使用 MediaPlayer 框架的 MPMoviePlayerViewController(MPMoviePlayerController/MPMoviePlayer) 播放视频文件或流。<br>使用 AVFoundation 框架的 AVPlayer 播放视频文件或流、 AVCaptureSession 录制视频帧。<br>在 iOS 8 之前使用 AVFoundation 框架的 AVAssetWritter 将 YUV 数据写入 H.264 编码格式的视频文件，而且使用的是硬编码。<br>在 iOS 8 及以后使用 VideoToolBox 框架将 YUV 视频数据硬编码为 H.264 ，以及将 H.264 硬解码为 YUV 视频数据。<br>在 iOS 8 及以后可以使用 AVKit 框架的 AVPlayerController 播放视频文件或流。<br>使用 GLKit 将 sRGB 或 YUV 视频数据渲染输出到屏幕。<br>使用 FFmpeg 将 H.264 软解码为 YUV 。<br>使用 x264 将 YUV 视频软编码为 H.264 。</p><p>1、官方资料<br>a:综合<br>Audio &amp; Video Starting Point<br>Multimedia Programming Guide<br>Core Audio Overview<br>Audio Session Programming Guide<br>b.MediaPlayer<br>Media Player Framework Reference<br>iPod Library Access Programming Guide<br>c.Audio Toolbox<br>Audio Toolbox Framework Reference<br>Audio Queue Programming Guide<br>d.Audio Unit<br>Audio Unit Programming Guide<br>Audio Unit Hosting Guide For iOS<br>e.AV Foundation<br>AV Foundation Framework Reference<br>AV Foundation Programming Guide<br>f.编解码及文件格式<br>CAF File Overview<br>Core Audio Format Specification<br>Apple Core Audio Format Specification 1.0<br>g.WWDC<br>WWDC 2013 606 : Moving to AVKit and AVFoundation<br>WWDC 2014 503 : Direct access to media encoding and decoding</p><p>2、第三方资料<br>Learning Core Audio<br>Audio file format<br>Comparison of audio coding formats<br>List of codecs<br>List of open-source codecs<br>Comparison of video codecs<br>Comparison of video container formats<br>Color space (YUV、sRGB)<br>objc.io #12 相机与照片<br>objc.io #23 视频<br>objc.io #24 音频<br><a href="http://msching.github.io/blog/2014/07/07/audio-in-ios/" target="_blank" rel="noopener">http://msching.github.io/blog/2014/07/07/audio-in-ios/</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Web前端之路</title>
      <link href="/2018/08/01/%E5%85%B6%E4%BB%96/Web%E5%89%8D%E7%AB%AF%E4%B9%8B%E8%B7%AF/"/>
      <url>/2018/08/01/%E5%85%B6%E4%BB%96/Web%E5%89%8D%E7%AB%AF%E4%B9%8B%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<p>#Web前端之路<br>一部分：学习时间：1.5月</p><p>html+div+css+ps切图+ftp网站上传（网站上线）阿里图标+html5标签+css3动画+手机网站开发+swiper.js+iscroll.js</p><p>二部分：学习时间：2.5月</p><p>JavaScript+jQuery+Ajax+正则表达式+面向对象+js插件+代码性能优化+github+sea.js+require.js+gulp</p><p>三部分：学习时间：2月</p><p>2D+3D应用+移动触屏事件touch+Canvas+Svg+多媒体技术+地理信息+本地存储+H5拖拽api+跨域操作+多线程+highcharts图表+bootstrap</p><p>思维导图</p><p><a href="https://www.processon.com/view/link/57d28d0ee4b0942d7a89c9dd" target="_blank" rel="noopener">https://www.processon.com/view/link/57d28d0ee4b0942d7a89c9dd</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git初识</title>
      <link href="/2018/07/27/%E5%85%B6%E4%BB%96/Git%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/07/27/%E5%85%B6%E4%BB%96/Git%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Git使用"><a href="#Git使用" class="headerlink" title="Git使用"></a>Git使用</h1><h2 id="1、创建空目录"><a href="#1、创建空目录" class="headerlink" title="1、创建空目录"></a>1、创建空目录</h2><pre><code>$ mkdir learngit$ cd learngit$ pwd/Users/michael/learngit</code></pre><blockquote><p>pwd用于显示当前目录</p></blockquote><h2 id="2、初始化仓库"><a href="#2、初始化仓库" class="headerlink" title="2、初始化仓库"></a>2、初始化仓库</h2><pre><code>git initInitialized empty Git repository in /Users/michael/learngit/.git/</code></pre><blockquote><p>ls -ah 查看隐藏文件</p></blockquote><h2 id="3、添加文件至版本库"><a href="#3、添加文件至版本库" class="headerlink" title="3、添加文件至版本库"></a>3、添加文件至版本库</h2><p>将新建的文件放置在新建的仓库learngit目录下</p><h4 id="3-1、-添加"><a href="#3-1、-添加" class="headerlink" title="3.1、 添加"></a>3.1、 添加</h4><pre><code>$ git add readme.txt</code></pre><h4 id="3-2、-提交"><a href="#3-2、-提交" class="headerlink" title="3.2、 提交"></a>3.2、 提交</h4><pre><code>$ $ git commit -m "wrote a readme file"[master (root-commit) eaadf4e] wrote a readme file 1 file changed, 2 insertions(+) create mode 100644 readme.txt</code></pre><h4 id="3-3、-状态"><a href="#3-3、-状态" class="headerlink" title="3.3、 状态"></a>3.3、 状态</h4><pre><code>$ git status</code></pre><h4 id="3-4、-修改的地方"><a href="#3-4、-修改的地方" class="headerlink" title="3.4、  修改的地方"></a>3.4、  修改的地方</h4><pre><code>$ git diff</code></pre><h4 id="3-5、-历史记录"><a href="#3-5、-历史记录" class="headerlink" title="3.5、 历史记录"></a>3.5、 历史记录</h4><pre><code>$ git log</code></pre>或者<pre><code>$ git log --pretty=oneline</code></pre><blockquote><p>成行显示</p></blockquote><h2 id="4、-版本回退"><a href="#4、-版本回退" class="headerlink" title="4、 版本回退"></a>4、 版本回退</h2><pre><code>$ git reset --hard HEAD^</code></pre><p>git 中HEAD表示当前版本， HEAD^^ 表示上一个版本，HEAD^^ 表示上上个版本，依次类推<br>当然若回退版本过多，写 ^^ 容易出错，可用 HEAD~100 ，往上100个版本。</p><pre><code>git reset --hard c87d5c3</code></pre><p>c87d5c3即为之前提交GPL时的ID， 可以不必写全，但也不能写一两位，避免重复</p><h2 id="5、-命令记录"><a href="#5、-命令记录" class="headerlink" title="5、 命令记录"></a>5、 命令记录</h2><pre><code>$ git reflog</code></pre><blockquote><p>HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset –hard commit_id。</p></blockquote><blockquote><p>穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。</p></blockquote><blockquote><p>要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。</p></blockquote><h2 id="6、-工作区、暂存区"><a href="#6、-工作区、暂存区" class="headerlink" title="6、 工作区、暂存区"></a>6、 工作区、暂存区</h2><p>git add 实际上是把当前所有修改都添加到暂存区<br>git commit 就可以一次性把暂存区的所有修改提交到分支</p><h2 id="7、-Git管理修改"><a href="#7、-Git管理修改" class="headerlink" title="7、 Git管理修改"></a>7、 Git管理修改</h2><blockquote><p>第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git commit</p></blockquote><p>上述操作最终只提交了 第一次修改，第二次并未提交，因为第二次修改并未add到暂存区</p><blockquote><p>第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git add -&gt; git commit</p></blockquote><p>此操作代表两次都已经提交</p><h2 id="8、-撤销修改"><a href="#8、-撤销修改" class="headerlink" title="8、 撤销修改"></a>8、 撤销修改</h2><p>丢弃工作区的修改</p><pre><code>$ git checkout -- readme.txt</code></pre>暂存区修改撤销，放回工作区<pre><code>$ git reset HEAD readme.txt</code></pre><h2 id="9、-删除文件"><a href="#9、-删除文件" class="headerlink" title="9、 删除文件"></a>9、 删除文件</h2><pre><code>$ git rv readme.txt</code></pre><h2 id="10、-添加远程仓库"><a href="#10、-添加远程仓库" class="headerlink" title="10、 添加远程仓库"></a>10、 添加远程仓库</h2><p>连接远程仓库，server-name即为Github账户名</p><pre><code>$ git remote add origin git@server-name:path/repo-name.git</code></pre><p>第一次推送</p><pre><code>$ git push -u origin master</code></pre><p>后续修改推送</p><pre><code>$ git push origin master</code></pre><h2 id="11、-克隆远程仓库"><a href="#11、-克隆远程仓库" class="headerlink" title="11、 克隆远程仓库"></a>11、 克隆远程仓库</h2><pre><code>$ git clone git@github.com:michaelliao/gitskills.git</code></pre>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HTTP头域</title>
      <link href="/2018/07/20/iOS%E5%BC%80%E5%8F%91/Http%E5%A4%B4%E5%9F%9F/"/>
      <url>/2018/07/20/iOS%E5%BC%80%E5%8F%91/Http%E5%A4%B4%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP常见头域"><a href="#HTTP常见头域" class="headerlink" title="HTTP常见头域"></a>HTTP常见头域</h1><p>##HTTP Request header（请求头）</p><p>###1、Cache头域</p><p>if-Modified-since：缓存</p><p>if-None-Match：可提高性能（在Response中添加ETag信息，客户端再次请求资源，Request中加入if-None-Match（ETag的值），服务器验证ETag，若没改变返回状态码304，有改变，返回状态码200）</p><p>Pragma：防止页面被缓存</p><p>Cache-Control：Response—Request遵循的缓存机制</p><p>　　public：可以被任何缓存所缓存</p><p>　　private:内容只缓存在私有缓存中</p><p>　　no-cache：所有内容都不会被缓存</p><p>###2、Client头域</p><p>Accept：浏览器可以接受的文件类型（Accept：text/html 表示浏览器可接受服务器返回的文件类型为text/html）</p><p>Accept-Encodig：指定压缩方法，是否支持压缩，支持什么压缩方法（gzip、deflate）</p><p>Accept-Language：浏览器申明自己的接收语言</p><p>User-Accept：告知服务器客户端使用的操作系统与浏览器的名称和版本</p><p>Accept-chareset：浏览器申明自己接收的字符集。如gb2312，UTF_8</p><p>###3、Cookie/Login头域</p><p>Cookie：将cookie的值发送给服务器</p><p>###4、Entity头域</p><p>Content-Length：发送给HTTP服务器的数据长度</p><p>Content-Type：决定文件接收方将以什么形式、什么编码读取此文件</p><p>###5、Miscellaneous头域</p><p>Referer：提供了Request的上下文信息，告诉服务器我是从哪个链接过来的</p><p>A——&gt;B（B的服务器从Referer中统计有多少用户是从A过来的）</p><p>###6、Transport头域</p><p>connection：Keep—alive            TCP连接不会关闭</p><p>connection：close                     一个Request完成后，TCP连接关闭</p><p>###7、Host：<br>发送请求时，该报头域是必需的。主要用于指定被请求资源的Internet主机和端口号，通常从HTTP URL 中提取出来</p><p>##HTTP Response header（返回头）</p><p>###1、Cache头域</p><p>Date：生成消息的具体时间和日期</p><p>Expires：浏览器在指定过期时间内使用本地缓存</p><p>###2、Cookie/Login头域</p><p>P3P：用户跨域设置cookie，可以解决iframe跨域访问cookie的问题</p><p>Set-Cookie：重要的header，用于把cookie发送到客户端浏览器，每一个写入cookie都会生成一个set-cookie</p><p>###3、Entity头域</p><p>ETag：与if-None-Match配合使用</p><p>Last-Modified：用于指示资源的最后修改日期和时间</p><p>Content-Type：Web服务器告知浏览器自己响应对象的类型和字符集</p><p>Content-Length：指明实体正文长度，以字节方式存储的十进制数字表示。在数据下行中，要预先在服务器中缓存所有数据，然后所有数据一并发给客户端</p><p>Content-Encoding：Web服务器表明自己用了什么压缩方式（gzip、deflate）压缩响应中的对象</p><p>Content-Language：服务器告知浏览器自己响应的对象语言</p><p>###4、Miscellaneous头域</p><p>Server：指明HTTP服务器的软件信息</p><p>X-Powered-By：表明网站是用什么技术开发的</p><p>X-AspNet-Version：如果网站是用Asp/Net开发的，这个header用来表明Asp/Net的版本</p><p>###5、Transport头域</p><p>connection：Keep—alive            TCP连接不会关闭</p><p>connection：close                     一个Request完成后，TCP连接关闭</p><p>###6、Location头域</p><p>Location：用于重定向一个新的位置，包括新的URL地址</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>iOS 数据加密</title>
      <link href="/2018/07/05/iOS%E5%BC%80%E5%8F%91/iOS%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86/"/>
      <url>/2018/07/05/iOS%E5%BC%80%E5%8F%91/iOS%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h1 id="常用加密算法"><a href="#常用加密算法" class="headerlink" title="常用加密算法"></a>常用加密算法</h1><h2 id="Base64加密"><a href="#Base64加密" class="headerlink" title="Base64加密"></a>Base64加密</h2><h2 id="MD5加密"><a href="#MD5加密" class="headerlink" title="MD5加密"></a>MD5加密</h2><p><a href="https://www.cmd5.com/" target="_blank" rel="noopener">https://www.cmd5.com/</a></p><h2 id="AES加密"><a href="#AES加密" class="headerlink" title="AES加密"></a>AES加密</h2><h2 id="RSA加密"><a href="#RSA加密" class="headerlink" title="RSA加密"></a>RSA加密</h2>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>iOS动画-炫酷效果从此刻开始</title>
      <link href="/2018/06/28/iOS%E5%BC%80%E5%8F%91/iOS%E5%8A%A8%E7%94%BB/"/>
      <url>/2018/06/28/iOS%E5%BC%80%E5%8F%91/iOS%E5%8A%A8%E7%94%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>IOS 动画主要是指Core Animation框架。官方使用文档地址为：<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreAnimation_guide/Introduction/Introduction.html" target="_blank" rel="noopener">Core Animation Guide</a>。<br>Core Animation是IOS和OS X平台上负责图形渲染与动画的基础框架。Core Animation可以作用与动画视图或者其他可视元素，为你完成了动画所需的大部分绘帧工作。你只需要配置少量的动画参数（如开始点的位置和结束点的位置）即可使用Core Animation的动画效果。Core Animation将大部分实际的绘图任务交给了图形硬件来处理，图形硬件会加速图形渲染的速度。这种自动化的图形加速技术让动画拥有更高的帧率并且显示效果更加平滑，不会加重CPU的负担而影响程序的运行速度。</p><p>那些酷炫的实现，其实进行步骤分解，你就会发现都是基础动画合理的搭配组合，对坐标尺寸、视图显示、形态变化一一进行了代码描述，就形成了你呈现在你眼前的动画效果。</p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="https://camo.githubusercontent.com/9fe3e0f9f3a1a750292d80b899b395a5b20f85b0/687474703a2f2f696d672e6d792e6373646e2e6e65742f75706c6f6164732f3230313530372f32332f313433373631373536325f333139302e706e67" alt=""></p><h2 id="常用属性"><a href="#常用属性" class="headerlink" title="常用属性"></a>常用属性</h2><p>duration:动画持续时间<br>beginTime:动画开始时间<br>repeatCount:动画重复次数<br>autoreverses:执行的动画按照原动画返回执行<br>timingFunction:控制动画的显示节奏，系统主要提供了以下几种</p><blockquote><p>kCAMediaTimingFunctionLinear 线性动画<br>kCAMediaTimingFunctionEaseIn 先慢后快（慢进快出）<br>kCAMediaTimingFunctionEaseOut 先块后慢（快进慢出）<br>kCAMediaTimingFunctionEaseInEaseOut 先慢后快再慢<br>kCAMediaTimingFunctionDefault 默认，也属于中间比较快</p></blockquote><p>delegate ： 动画代理。能够检测动画的执行和结束。</p><blockquote><p>@interface NSObject (CAAnimationDelegate)</p><ul><li>(void)animationDidStart:(CAAnimation *)anim;</li><li>(void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag;<br>@end</li></ul></blockquote><p>path:关键帧动画中的执行路径<br>type:过渡动画的动画类型，系统提供了四种过渡动画。</p><blockquote><p>kCATransitionFade 渐变效果<br>kCATransitionMoveIn 进入覆盖效果<br>kCATransitionPush 推出效果<br>kCATransitionReveal 揭露离开效果 subtype : 过渡动画的动画方向<br>kCATransitionFromRight 从右侧进入<br>kCATransitionFromLeft 从左侧进入<br>kCATransitionFromTop 从顶部进入<br>kCATransitionFromBottom 从底部进入</p></blockquote><h2 id="动画的三种调用方式"><a href="#动画的三种调用方式" class="headerlink" title="动画的三种调用方式"></a>动画的三种调用方式</h2><h3 id="使用block"><a href="#使用block" class="headerlink" title="使用block"></a>使用block</h3><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>UIView animateWithDuration:1.0f animations:^<span class="token punctuation">{</span>      self.animationView.frame <span class="token operator">=</span> CGRectMake<span class="token punctuation">(</span>SCREEN_WIDTH, SCREEN_HEIGHT/2-100, 50, 50<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> completion:^<span class="token punctuation">(</span>BOOL finished<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre><h3 id="UIView-begin-commit"><a href="#UIView-begin-commit" class="headerlink" title="UIView [begin commit]"></a>UIView [begin commit]</h3><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>UIView beginAnimations:nil context:nil<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">[</span>UIView setAnimationDuration:1.0f<span class="token punctuation">]</span><span class="token punctuation">;</span>self.animationView.frame <span class="token operator">=</span> CGRectMake<span class="token punctuation">(</span>SCREEN_WIDTH, SCREEN_HEIGHT/2-100, 50, 50<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">[</span>UIView commitAnimations<span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre><h3 id="CABaseAnimation"><a href="#CABaseAnimation" class="headerlink" title="CABaseAnimation"></a>CABaseAnimation</h3><pre class=" language-bash"><code class="language-bash">CABasicAnimation *anima <span class="token operator">=</span> <span class="token punctuation">[</span>CABasicAnimation animationWithKeyPath:@<span class="token string">"position"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>anima.fromValue <span class="token operator">=</span> <span class="token punctuation">[</span>NSValue valueWithCGPoint:CGPointMake<span class="token punctuation">(</span>0, SCREEN_HEIGHT/2-100<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>anima.toValue <span class="token operator">=</span> <span class="token punctuation">[</span>NSValue valueWithCGPoint:CGPointMake<span class="token punctuation">(</span>SCREEN_WIDTH, SCREEN_HEIGHT/2-75<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>anima.duration <span class="token operator">=</span> 2.0f<span class="token punctuation">;</span>//fillMode<span class="token operator">=</span>kCAFillModeForwards和removedOnComletion<span class="token operator">=</span>NOanima.fillMode <span class="token operator">=</span> kCAFillModeBackwards<span class="token punctuation">;</span>anima.removedOnCompletion <span class="token operator">=</span> YES<span class="token punctuation">;</span>anima.timingFunction <span class="token operator">=</span> <span class="token punctuation">[</span>CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseIn<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">[</span>self.animationView.layer addAnimation:anima forKey:@<span class="token string">"positionAnimation"</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre><h2 id="一、基础动画"><a href="#一、基础动画" class="headerlink" title="一、基础动画"></a>一、基础动画</h2><p>重要属性</p><blockquote><p>fromValue：keyPath对应的初始值<br>toValue：keyPath对应的结束值</p></blockquote><p>基础动画主要提供了对于CALayer对象中的可变属性进行简单动画的操作。比如：位移(position)、透明度(opacity)、缩放(scale)、旋转(rotate)、背景色(backgroundColor)等等。<br>具体效果实例演示</p><h2 id="二、关键帧动画-keyAnimation"><a href="#二、关键帧动画-keyAnimation" class="headerlink" title="二、关键帧动画(keyAnimation)"></a>二、关键帧动画(keyAnimation)</h2><p>具体效果实例演示</p><h2 id="三、动画组-animationGroup"><a href="#三、动画组-animationGroup" class="headerlink" title="三、动画组(animationGroup)"></a>三、动画组(animationGroup)</h2><p>具体效果实例演示</p><h2 id="三、转场动画-transition"><a href="#三、转场动画-transition" class="headerlink" title="三、转场动画 (transition)"></a>三、转场动画 (transition)</h2><p>iOS7开始，苹果就提供了自定义转场的API，模态推送present和dismiss、导航控制器push和pop、标签控制器的控制器切换都可以自定义转场，具体效果实例演示</p><h3 id="1、转场协议"><a href="#1、转场协议" class="headerlink" title="1、转场协议"></a>1、转场协议<uiviewcontrolleranimatedtransitioning></uiviewcontrolleranimatedtransitioning></h3><p>转场动画的实现 遵从上面这个协议以及实现协议中的两个方法，如下：</p><pre class=" language-bash"><code class="language-bash">//返回动画事件  - <span class="token punctuation">(</span>NSTimeInterval<span class="token punctuation">)</span>transitionDuration:<span class="token punctuation">(</span>nullable <span class="token function">id</span> <span class="token operator">&lt;</span>UIViewControllerContextTransitioning<span class="token operator">></span><span class="token punctuation">)</span>transitionContext<span class="token punctuation">;</span>//所有的过渡动画事务都在这个方法里面完成- <span class="token punctuation">(</span>void<span class="token punctuation">)</span>animateTransition:<span class="token punctuation">(</span>id <span class="token operator">&lt;</span>UIViewControllerContextTransitioning<span class="token operator">></span><span class="token punctuation">)</span>transitionContext<span class="token punctuation">;</span></code></pre><h2 id="四、动画扩展"><a href="#四、动画扩展" class="headerlink" title="四、动画扩展"></a>四、动画扩展</h2><h3 id="1、Lottie动画库"><a href="#1、Lottie动画库" class="headerlink" title="1、Lottie动画库"></a>1、Lottie动画库</h3><h4 id="1-1、简介"><a href="#1-1、简介" class="headerlink" title="1.1、简介"></a>1.1、简介</h4><p>Easily add high-quality animation to any native app.<br>Lottie is an iOS, Android, and React Native library that renders After Effects animations in real time, allowing apps to use animations as easily as they use static images.</p><p>简单的为任何原生APP添加高质量动画<br>Lottie是一个iOS，Android和React Native库，可以实时渲染After Effects动画，并且允许本地app像静态资源那样轻松地使用动画。<br><img src="https://raw.githubusercontent.com/airbnb/lottie-android/master/gifs/Example1.gif" alt=""><br><img src="https://raw.githubusercontent.com/airbnb/lottie-ios/master/_Gifs/Examples2.gif" alt=""></p><h4 id="1-2、使用（以OC为例）"><a href="#1-2、使用（以OC为例）" class="headerlink" title="1.2、使用（以OC为例）"></a>1.2、使用（以OC为例）</h4><h3 id="2、facebook开源动画库"><a href="#2、facebook开源动画库" class="headerlink" title="2、facebook开源动画库"></a>2、facebook开源动画库</h3><h4 id="2-1、开源地址-https-github-com-facebook-pop"><a href="#2-1、开源地址-https-github-com-facebook-pop" class="headerlink" title="2.1、开源地址 https://github.com/facebook/pop"></a>2.1、开源地址 <a href="https://github.com/facebook/pop" target="_blank" rel="noopener">https://github.com/facebook/pop</a></h4>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础动画 </tag>
            
            <tag> 核心动画 </tag>
            
            <tag> 炫酷 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AppDelegate的瘦身之路</title>
      <link href="/2018/06/28/iOS%E5%BC%80%E5%8F%91/AppDelegate%E7%98%A6%E8%BA%AB%E4%B9%8B%E8%B7%AF/"/>
      <url>/2018/06/28/iOS%E5%BC%80%E5%8F%91/AppDelegate%E7%98%A6%E8%BA%AB%E4%B9%8B%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>项目开发中,随着时间的推移,项目业务结构的越来越复杂,引入的东西越来越多,作为一个app入口的AppDelegate,会变得越来越“肥胖”,会发现里面有第三方分享注册、消息推送注册、友盟统计、键盘管理工具初始化等等,代码写的再工整, 也会显的这个入口很拥挤.所以就有了减肥计划的开始.</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h2 id="AOP面向切面编程"><a href="#AOP面向切面编程" class="headerlink" title="AOP面向切面编程"></a>AOP面向切面编程</h2><h2 id="load"><a href="#load" class="headerlink" title="load"></a>load</h2>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> appDelagte </tag>
            
            <tag> 减肥瘦身 </tag>
            
            <tag> 剥离 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AppStore审核之路</title>
      <link href="/2018/06/28/iOS%E5%BC%80%E5%8F%91/AppStore%E5%AE%A1%E6%A0%B8%E4%B9%8B%E8%B7%AF/"/>
      <url>/2018/06/28/iOS%E5%BC%80%E5%8F%91/AppStore%E5%AE%A1%E6%A0%B8%E4%B9%8B%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>作为一个iOS开发来说，头疼的不是提出的需求有多么难实现，也不是出现的bug有多么难解决，而是app开发完成，测试完美ending,你以为这样就万事大吉了？错❌，最后一个可大可小的 坑，也许会让你一两个月都爬不出来，那就是 AppStore上架审核。</p><p>相对于安卓应用，iOS版本的发布，乔布斯真的没给你太多选择，果断还是有钱人说了算，那么只能听他安排，乖乖的去App Store 填写一大串基本信息，上传安装包，提交审核。别看口头上说的貌似挺简单，只有当你亲身经历，屡遭苹果毒手，才知道什么叫绝望。</p><h2 id="App-Store三步曲"><a href="#App-Store三步曲" class="headerlink" title="App Store三步曲"></a>App Store三步曲</h2><p>在描述我惨痛经历之前，先给大家介绍下App Store审核的流程</p><font color="#DC143C"><strong>苹果审核大体分为三部分，预审、机审和人工审核</strong>。</font><p>目前应用提审的整个流程大体分为五个阶段：<br><strong><font color="#2E8B57">Prepare For Upload（准备上传）<br>Waiting For Review（等待审核）<br>In Review（审核）<br>Pending Developer Release(等待开发者发布）<br>Ready For Sale（准备销售）</font></strong></p><p>APP上传后，会进入到 Wait for Review 状态，而后进入到In Review状态，In Review一般2天左右就会审核通过或者是被打回。</p><p>包上传后首先进入的是预审，会被扫描API等，预审通过后会在iTC里出现，然后才可以提交至 Waiting；</p><p>在 Waiting For Review（等待审核）阶段一般是机审，机审主要是对代码进行机器审核，排查APP是否重复应用，更多地依赖机器自动审核，减少人工成本；</p><p>通过后会进入In Review（审核）阶段，即人工审核阶段，这个阶段主要看的是App的元数据，例如APP封面、功能、体验等等，注重用户体验。</p><p>苹果官方提供审核指南文档以及常见被拒总结：</p><p><a href="https://developer.apple.com/cn/app-store/launch/" target="_blank" rel="noopener">https://developer.apple.com/cn/app-store/launch/</a></p><p>那么下面就记录一下项目上线过程中那些层出不穷的拒绝理由</p><h2 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h2><h4 id="1、应用内带检查更新功能"><a href="#1、应用内带检查更新功能" class="headerlink" title="1、应用内带检查更新功能"></a>1、应用内带检查更新功能</h4><pre class=" language-bash"><code class="language-bash">Your app includes an update button or alerts the user to update the app. To avoid user confusion, app version updates must utilize the iOS built-in update mechanism. We’ve attached screenshot<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token keyword">for</span> your reference.Next StepsPlease remove the update feature from your app. To distribute a new version of your app, upload the new app binary version into the same iTunes Connect record you created <span class="token keyword">for</span> the app’s previous version. Updated versions keep the same Apple ID, iTunes Connect ID <span class="token punctuation">(</span>SKU<span class="token punctuation">)</span>, and bundle ID as the original version, and are available <span class="token function">free</span> to customers <span class="token function">who</span> purchased a previous version.</code></pre><blockquote><font color="#2E8B57"> <strong>解析：从2015年3月起，所有包含检查更新功能的 App 都会被拒绝上架。所以应用中不允许出现检查更新的字样，而且设计版本号的地方也不能有点击效果，否则苹果会误以为这是更新版本。</strong></font></blockquote><h4 id="2、iPhone-应用在-iPad-上不能正常显示"><a href="#2、iPhone-应用在-iPad-上不能正常显示" class="headerlink" title="2、iPhone 应用在 iPad 上不能正常显示"></a>2、iPhone 应用在 iPad 上不能正常显示</h4><pre class=" language-bash"><code class="language-bash">We noticed that your app did not run at iPhone resolution when reviewed on iPad running iOS 9.1, <span class="token function">which</span> is a violation of the App Store Review Guidelines. We’ve attached screenshot<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token keyword">for</span> your reference.Specifically, the buttons at the bottom of the app are inaccessible when running on iPad.Next StepsPlease revise your app to ensure it runs at iPhone resolution on iPad.</code></pre><blockquote><font color="#2E8B57"><strong>解析：iPhone程序必须不经修改就能以iPhone分辨率和2倍iPhone 3GS的分辨率在iPad上运行。即使你的App 只为 iPhone 用户提供，在 iPad 上也必须能够正常显示，否则审核会被拒绝。开发人员做好适配。</strong></font></blockquote><h4 id="3、使用第三方登录问题"><a href="#3、使用第三方登录问题" class="headerlink" title="3、使用第三方登录问题"></a>3、使用第三方登录问题</h4><pre class=" language-bash"><code class="language-bash">Additionally, we found that your app requires the installation of another app before it can be used, <span class="token function">which</span> is not <span class="token keyword">in</span> compliance with the App Store Review Guidelines. Apps should be able to run on launch, without requiring additional applications to be installed.    Specifically, we were required to <span class="token function">install</span> WeChat/QQ before we could use the sharing features <span class="token keyword">in</span> your app.    Please revise your app so that a user can use it upon launch. If your app requires authentication before use, please use a method that can authenticate <span class="token function">users</span> from within your app.</code></pre><blockquote><font color="#2E8B57"><strong>解析：接入第三方登录要检测是否安装了第三方客户端，未安装时不要显示对应按钮。2015年9月之前，通常可以采用判断未安装则隐藏登录按钮的方式。但目前隐藏按钮的方式也可能被审核拒绝，QQ 和微博提供了 web 登录的方式，如果判断未安装，需要允许用户使用 webview 的登录方式。苹果在条款中有声明不允许 iOS 应用的正常使用需要依赖另外一个 App。</strong></font></blockquote><p><strong><em><font color="#DC143C">以上这三点是开发人员开发过程中需要注意，并且可以主动去避免的。</font></em></strong></p><h4 id="4、Guideline-2-1-Information-Needed"><a href="#4、Guideline-2-1-Information-Needed" class="headerlink" title="4、Guideline 2.1 - Information Needed"></a>4、Guideline 2.1 - Information Needed</h4><pre class=" language-bash"><code class="language-bash">We have started the review of your app, but we were unable to successfully register <span class="token keyword">for</span> an in-app account. In order <span class="token keyword">for</span> us to review your app, please provide a demo account so that we may fully assess your app<span class="token string">'s features.Next StepsTo help us proceed with the review of your app, please provide a user name and password in the App Review Information section for your app in iTunes Connect. Please be sure to include content in your app that demonstrates the features and functionality available in your app.To provide demo account information:- Log in to iTunes Connect- Click "My Apps"- Select your app- Click on the app version on the left side of the screen- Scroll down to "App Review Information"- Select the "Sign-in required" box- Enter demo credentials in the "User name" and "Password" fields- Once you'</span>ve completed all changes, click the <span class="token string">"Save"</span> button at the <span class="token function">top</span> of the Version Information page.If your iTunes Connect status shows as Metadata Rejected, we <span class="token keyword">do</span> not require a new binary to correct this issue. Please reply to this message <span class="token keyword">in</span> Resolution Center to confirm the availability of a valid demo account, and we will <span class="token keyword">continue</span> with the review.</code></pre><blockquote><font color="#2E8B57"><strong>解析：根据描述，是提供的app登录帐号，苹果审核时输入并不能成功登录导致。所以这种情况<br>     第一，要确保服务器状态稳定，保证苹果审核期间接口都能正常请求<br>     第二，确保提供的帐号的确能够登录，并且后台数据库需要长期保留该帐号信息，勿删。</strong></font></blockquote><h4 id="5、Guideline-2-3-3-Performance-Accurate-Metadata"><a href="#5、Guideline-2-3-3-Performance-Accurate-Metadata" class="headerlink" title="5、Guideline 2.3.3 - Performance - Accurate Metadata"></a>5、Guideline 2.3.3 - Performance - Accurate Metadata</h4><pre class=" language-bash"><code class="language-bash">We noticed that your screenshots <span class="token keyword">do</span> not sufficiently reflect your app <span class="token keyword">in</span> use.Please see attached screenshots <span class="token keyword">for</span> details.Next StepsTo resolve this issue, please revise your screenshots to ensure that they accurately reflect the app <span class="token keyword">in</span> use on the supported devices. For iPhone, you need a <span class="token keyword">set</span> of 5.5-inch display screenshots and <span class="token keyword">for</span> iPad, you need a <span class="token keyword">set</span> <span class="token keyword">for</span> 12.9-inch display. This <span class="token keyword">set</span> will be scaled appropriately down to other device sizes when viewed on the App Store <span class="token keyword">in</span> each territory.ResourcesFor resources on creating great screenshots <span class="token keyword">for</span> the App Store, you may want to review the App Store Product Page information available on the Apple developer portal.Please ensure you have made any screenshot modifications using Media Manager. You should confirm your app looks and behaves identically <span class="token keyword">in</span> all languages and on all supported devices. Learn how to use Media Manager to add custom screenshots <span class="token keyword">for</span> each display size and localization.Since your iTunes Connect status is Metadata Rejected, we <span class="token keyword">do</span> NOT require a new binary. To revise the metadata, visit iTunes Connect to <span class="token keyword">select</span> your app and revise the desired metadata values. Once you’ve completed all changes, reply to this message <span class="token keyword">in</span> Resolution Center and we will <span class="token keyword">continue</span> the review.NOTE: Please be sure to <span class="token function">make</span> any metadata changes to all app localizations by selecting each specific localization and making appropriate changes.</code></pre><blockquote><font color="#2E8B57"><strong>解析：简单点说就是自己的应用截图不能反应自己App的主要功能，然后重新换了截图，能展示主要功能的截图即可。</strong></font></blockquote><h4 id="6、Guideline-2-1-Performance-App-Completeness"><a href="#6、Guideline-2-1-Performance-App-Completeness" class="headerlink" title="6、Guideline 2.1 - Performance - App Completeness"></a>6、Guideline 2.1 - Performance - App Completeness</h4><pre class=" language-bash"><code class="language-bash">We discovered one or <span class="token function">more</span> bugs <span class="token keyword">in</span> your app when reviewed on iPad running iOS 11.4.1 on Wi-Fi connected to an IPv6 network.Specifically, we were unable to fully load your app’s content during review.Next StepsTo resolve this issue, please run your app on a device to identify any issues, <span class="token keyword">then</span> revise and resubmit your app <span class="token keyword">for</span> review.If we misunderstood the intended behavior of your app, please reply to this message <span class="token keyword">in</span> Resolution Center to provide information on how these features were intended to work.For new apps, uninstall all previous versions of your app from a device, <span class="token keyword">then</span> <span class="token function">install</span> and follow the steps to reproduce the issue. For updates, <span class="token function">install</span> the new version as an update to the previous version, <span class="token keyword">then</span> follow the steps to reproduce the issue.ResourcesFor information about testing your app and preparing it <span class="token keyword">for</span> review, please see Technical Note TN2431: App Testing Guide.For a networking overview, please review About Networking. For a <span class="token function">more</span> specific overview of App Review’s IPv6 requirements, please review the IPv6 and App Review discussion on the Apple Developer Forum.Please see attached screenshot <span class="token keyword">for</span> details.</code></pre><blockquote><font color="#2E8B57"><strong>解析：ipv6的问题，具体参考以下地址 <a href="https://shimo.im/docs/r4WRJroUsdMJHPoa/" target="_blank" rel="noopener">https://shimo.im/docs/r4WRJroUsdMJHPoa/</a> 《iOS上架iPV6被拒问题》，可复制链接后用石墨文档 App 打开</strong></font>  </blockquote><h4 id="7、Guideline-5-1-1-Legal-Privacy-Data-Collection-and-Storage"><a href="#7、Guideline-5-1-1-Legal-Privacy-Data-Collection-and-Storage" class="headerlink" title="7、Guideline 5.1.1 - Legal - Privacy - Data Collection and Storage"></a>7、Guideline 5.1.1 - Legal - Privacy - Data Collection and Storage</h4><pre class=" language-bash"><code class="language-bash">We noticed that your app requests the user’s consent to access their camera but does not clarify the use of this feature <span class="token keyword">in</span> the permission modal alert.Next StepsTo resolve this issue, please revise the permission modal alert to specify why the app is requesting access to the user's camera.The permission request alert should specify how your app will use this feature to <span class="token function">help</span> <span class="token function">users</span> understand why your app is requesting access to their personal data.ResourcesFor additional information and instructions on configuring and presenting an alert, please review the Requesting Permission section of the iOS Human Interface Guidelines and the Information Property List Key Reference. You may also want to review the Technical Q<span class="token operator">&amp;</span>A QA1937: Resolving the Privacy-Sensitive Data App Rejection page <span class="token keyword">for</span> details on how to provide a usage description <span class="token keyword">for</span> permission request alerts.Learn <span class="token function">more</span> about Protecting the User’s Privacy.Please see attached screenshots <span class="token keyword">for</span> details.</code></pre><p>一般苹果会配备以下类似截图<br>    <img src="https://github.com/ReaperLC/Hello-World/blob/master/resource/app.png?raw=true" alt=""></p><blockquote><font color="#2E8B57"><strong>解析：自从iOS10之后加入了各种权限问题，比如相机、相册、网络、定位等等权限，应用中使用这些权限的过程中必须配备详细描述，使用这项权限干什么，比如请求使用您的定位权限，便于为您提供周边景区服务。所以描述完整很重要。</strong></font></blockquote><h4 id="8、Guideline-5-2-1-Legal-Intellectual-Property"><a href="#8、Guideline-5-2-1-Legal-Intellectual-Property" class="headerlink" title="8、Guideline 5.2.1 - Legal - Intellectual Property"></a>8、Guideline 5.2.1 - Legal - Intellectual Property</h4><pre class=" language-bash"><code class="language-bash">The seller and company names associated with your app <span class="token keyword">do</span> not reflect the name “西安市人民政府” <span class="token keyword">in</span> the app or its metadata, as required by Guideline 5.2.1 of the App Store Review Guidelines.Next StepsYour app must be published under a seller name and company name that reflects the 西安市人民政府 name. If you have developed this app on behalf of a client, please advise your client to add you to the development team of their Apple Developer account.Once created, you cannot change your seller name or company name <span class="token keyword">in</span> iTunes Connect. For assistance with changing your company name or seller name, you will need to contact iTunes Connect through the Contact Us page. Select Getting Started from the first dropdown menu, <span class="token keyword">then</span> <span class="token keyword">select</span> General iTunes Connect Inquiry to contact the appropriate iTunes Connect team.</code></pre><blockquote><font color="#2E8B57"><strong>解析：涉及到一个资质问题，大致就是说该帐号并不能代表某机构或者某组织去发布销售该应用，<br>       一般情况都是其他项目想用我们公司帐号上架，出现这种问题，也就是说我们公司暂时无法代表政<br>       府去发布某政务服务应用。一般解决方案去除应用中明显的字眼：比如xxx市人民政务，xxx市政<br>       务服务中心，或者直接客户自己提供开发者帐号，不用我们公司帐号上架</strong></font></blockquote><h4 id="9、应用出现-beta版、测试版字样"><a href="#9、应用出现-beta版、测试版字样" class="headerlink" title="9、应用出现 beta版、测试版字样"></a>9、应用出现 beta版、测试版字样</h4><pre class=" language-bash"><code class="language-bash">Your app appears to be a pre-release, test, or trial version with a limited feature set. Apps that are created <span class="token keyword">for</span> demonstration or trial purposes are not appropriate <span class="token keyword">for</span> the App Store and <span class="token keyword">do</span> not comply with the App Store Review Guidelines.To ensure compliance with the App Store Review Guidelines, it would be appropriate to revise your app to complete, remove, or fully configure any partially implemented feature<span class="token punctuation">(</span>s<span class="token punctuation">)</span>.If you would like to conduct beta trial <span class="token keyword">for</span> your app, you may wish to review the TestFlight Beta Testing Guide.</code></pre><blockquote><font color="#2E8B57"><strong>解析：不要过度谦虚地在启动画面或者应用名称上加上”beta”字样，苹果不允许测试版产品上架。也就是整个应用无论从启动到细枝末节的某个页面上都不要出现测试、beta字样，一经苹果审核到，基本都是被打回。</strong></font></blockquote>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AppStore </tag>
            
            <tag> 上架 </tag>
            
            <tag> 审核 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>世上本无坑，踩的人多了变有了坑</title>
      <link href="/2018/05/21/iOS%E5%BC%80%E5%8F%91/%E8%B8%A9%E5%9D%91%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/05/21/iOS%E5%BC%80%E5%8F%91/%E8%B8%A9%E5%9D%91%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="1、tableViewCell-分割线边距缩进"><a href="#1、tableViewCell-分割线边距缩进" class="headerlink" title="1、tableViewCell 分割线边距缩进"></a>1、tableViewCell 分割线边距缩进</h1><pre class=" language-bash"><code class="language-bash">-<span class="token punctuation">(</span>void<span class="token punctuation">)</span>tableView:<span class="token punctuation">(</span>UITableView *<span class="token punctuation">)</span>tableView willDisplayCell:<span class="token punctuation">(</span>UITableViewCell *<span class="token punctuation">)</span>cell forRowAtIndexPath:<span class="token punctuation">(</span>NSIndexPath *<span class="token punctuation">)</span>indexPath <span class="token punctuation">{</span>    // 设置分割线左右边距    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">[</span>cell respondsToSelector:@selector<span class="token punctuation">(</span>setSeparatorInset:<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">[</span>cell setSeparatorInset:UIEdgeInsetsMake<span class="token punctuation">(</span>0,100, 0,8<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    //    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">[</span>cell respondsToSelector:@selector<span class="token punctuation">(</span>setPreservesSuperviewLayoutMargins:<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">[</span>cell setPreservesSuperviewLayoutMargins:NO<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    // 设置cell左右边距    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">[</span>cell respondsToSelector:@selector<span class="token punctuation">(</span>setLayoutMargins:<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">[</span>cell setLayoutMargins:UIEdgeInsetsMake<span class="token punctuation">(</span>0, 8, 0,8<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>#2、cocoapods降级操作</p><p> 1查看当前版本</p><pre class=" language-bash"><code class="language-bash">pod --version</code></pre><p> 2查看安装列表</p><pre class=" language-bash"><code class="language-bash">gem list</code></pre><p>3卸载</p><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> gem uninstall cocoapods -v 1.3.1</code></pre><p>4安装</p><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> gem <span class="token function">install</span> cocoapods -v 1.3.1</code></pre><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> gem uninstall cocoapods</code></pre><p>先查看本地安装过的cocopods相关东西，命令如下：<br>$ gem list –local | grep cocoapods<br>会显示如下：</p><blockquote><p>cocoapods-core (0.39.0)<br>cocoapods-downloader (0.9.3)<br>cocoapods-plugins (0.4.2)<br>cocoapods-search (0.1.0)<br>cocoapods-stats (0.6.2)<br>cocoapods-trunk (0.6.4)<br>cocoapods-try (0.5.1)<br>然后逐个删除吧：</p></blockquote><pre class=" language-bash"><code class="language-bash">$ <span class="token function">sudo</span> gem uninstall cocoapods-core</code></pre><p>#2.1 安装RVM</p><pre class=" language-bash"><code class="language-bash">curl -L get.rvm.io <span class="token operator">|</span> <span class="token function">bash</span> -s stable<span class="token function">source</span> ~/.bashrc<span class="token function">source</span> ~/.bash_profilervm -vrvm list knownrvm <span class="token function">install</span> 2.3.0</code></pre><p>#3、Runtime之交换方法</p><pre class=" language-bash"><code class="language-bash">+ <span class="token punctuation">(</span>void<span class="token punctuation">)</span>methodSwizzlingWithOriginalSelector:<span class="token punctuation">(</span>SEL<span class="token punctuation">)</span>originalSelector                         bySwizzledSelector:<span class="token punctuation">(</span>SEL<span class="token punctuation">)</span>swizzledSelector <span class="token punctuation">{</span>    static dispatch_once_t onceToken<span class="token punctuation">;</span>    dispatch_once<span class="token punctuation">(</span><span class="token operator">&amp;</span>onceToken, ^<span class="token punctuation">{</span>        Class class <span class="token operator">=</span> <span class="token punctuation">[</span>self class<span class="token punctuation">]</span><span class="token punctuation">;</span>        Method originalMethod <span class="token operator">=</span> class_getInstanceMethod<span class="token punctuation">(</span>class, originalSelector<span class="token punctuation">)</span><span class="token punctuation">;</span>        Method swizzledMethod <span class="token operator">=</span> class_getInstanceMethod<span class="token punctuation">(</span>class, swizzledSelector<span class="token punctuation">)</span><span class="token punctuation">;</span>        BOOL didAddMethod <span class="token operator">=</span> class_addMethod<span class="token punctuation">(</span>class,originalSelector,                                            method_getImplementation<span class="token punctuation">(</span>swizzledMethod<span class="token punctuation">)</span>,                                            method_getTypeEncoding<span class="token punctuation">(</span>swizzledMethod<span class="token punctuation">))</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>didAddMethod<span class="token punctuation">)</span> <span class="token punctuation">{</span>            class_replaceMethod<span class="token punctuation">(</span>class,swizzledSelector,                                method_getImplementation<span class="token punctuation">(</span>originalMethod<span class="token punctuation">)</span>,                                method_getTypeEncoding<span class="token punctuation">(</span>originalMethod<span class="token punctuation">))</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            method_exchangeImplementations<span class="token punctuation">(</span>originalMethod, swizzledMethod<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>#上架应用预览<br>    <a href="https://itunes.apple.com/cn/app/yan-yu/id1393900517" target="_blank" rel="noopener">https://itunes.apple.com/cn/app/yan-yu/id1393900517</a>    </p><h1 id="系统相册界面上移"><a href="#系统相册界面上移" class="headerlink" title="系统相册界面上移"></a>系统相册界面上移</h1><p>是因为全局设置了ScrollView属性导致的.</p><pre class=" language-bash"><code class="language-bash"><span class="token keyword">if</span> <span class="token punctuation">(</span>@available<span class="token punctuation">(</span>iOS 11.0, *<span class="token punctuation">))</span><span class="token punctuation">{</span>//避免滚动视图顶部出现20的空白以及push或者pop的时候页面有一个上移或者下移的异常动画的问题        <span class="token punctuation">[</span><span class="token punctuation">[</span>UIScrollView appearance<span class="token punctuation">]</span> setContentInsetAdjustmentBehavior:UIScrollViewContentInsetAdjustmentNever<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>  在调用相册前重置就好了</p><pre class=" language-bash"><code class="language-bash"><span class="token keyword">if</span> <span class="token punctuation">(</span>@available<span class="token punctuation">(</span>iOS 11, *<span class="token punctuation">))</span> <span class="token punctuation">{</span>        UIScrollView.appearance.contentInsetAdjustmentBehavior <span class="token operator">=</span> UIScrollViewContentInsetAdjustmentAutomatic<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h1 id="如何防止反编译"><a href="#如何防止反编译" class="headerlink" title="如何防止反编译"></a>如何防止反编译</h1><p>1、对本地数据存储NSUserDefault,sqlite进行加密处理，保护关键信息    （本地数据加密）<br>2、对程序中出现的URL进行加密处理，防止URL被静态分析                 (URL地址加密)<br>3、对客户端的网路请求数据进行加密，防止通过网络拦截获取数据           (请求数据加密)<br>4、代码混淆<br>5、第三方防护，网易云盾</p><h1 id="Xcode编译错误"><a href="#Xcode编译错误" class="headerlink" title="Xcode编译错误"></a>Xcode编译错误</h1><pre><code>Warning: The Copy Bundle Resources build phase contains this target&#39;s Info.plist file &#39;Proj/Other/Info.plist&#39;.编译时将 info.plist文件也进行了编译</code></pre><p><strong>解决方案: 在 Copy Bundle Resources中将警告文件删除重新编译即可</strong></p>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>iOS Runtime的妙用</title>
      <link href="/2018/05/21/iOS%E5%BC%80%E5%8F%91/Runtime%E5%A6%99%E7%94%A8/"/>
      <url>/2018/05/21/iOS%E5%BC%80%E5%8F%91/Runtime%E5%A6%99%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p><img src="https://github.com/ReaperLC/Hello-World/blob/master/resource/Runtime.png?raw=true" alt=""></p><p>Runtime是一套底层的C语言API（包含强大的C语言数据类型和函数）,RunTime简称运行时。OC就是运行时机制，其中最主要的是消息机制。</p><p>苹果和GNU各自维护一个开源的runtime版本<br><a href="https://github.com/opensource-apple/objc4" target="_blank" rel="noopener">https://github.com/opensource-apple/objc4</a> (Apple)</p><h2 id="消息机制"><a href="#消息机制" class="headerlink" title="消息机制"></a>消息机制</h2><p>Runtime进行方法调用本质上是发送消息，通过objc_msgSend()函数进行消息发送,下面就以一个对象的实例化为例</p><pre class=" language-bash"><code class="language-bash">Person *p <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>Person alloc<span class="token punctuation">]</span> init<span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre><p>对于我们平常使用的初始化方法 alloc、 init、new,如果用消息机制分解步骤具体如下:</p><pre class=" language-bash"><code class="language-bash">//通过类名获取类Class class <span class="token operator">=</span> objc_getClass<span class="token punctuation">(</span><span class="token string">"Person"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>//注意Class实际上也是对象，所以同样能够接受消息，向Class发送alloc消息Person *p <span class="token operator">=</span> objc_msgSend<span class="token punctuation">(</span>class,@selector<span class="token punctuation">(</span>alloc<span class="token punctuation">))</span><span class="token punctuation">;</span>//发送init消息给Person实例pp <span class="token operator">=</span> objc_msgSend<span class="token punctuation">(</span>p,@selector<span class="token punctuation">(</span>init<span class="token punctuation">))</span><span class="token punctuation">;</span>//发送run消息给p 即调用run实例方法objc_msgSend<span class="token punctuation">(</span>p, @selector<span class="token punctuation">(</span>run<span class="token punctuation">))</span><span class="token punctuation">;</span>//汇总传递消息链objc_msgSend<span class="token punctuation">(</span>objc_msgSend<span class="token punctuation">(</span>objc_msgSend<span class="token punctuation">(</span>objc_getClass<span class="token punctuation">(</span><span class="token string">"Person"</span><span class="token punctuation">)</span>, @selector<span class="token punctuation">(</span>alloc<span class="token punctuation">))</span>, @selector<span class="token punctuation">(</span>init<span class="token punctuation">))</span>, @selector<span class="token punctuation">(</span>run<span class="token punctuation">))</span><span class="token punctuation">;</span></code></pre><blockquote><p><strong>如果只申明了方法编号 ,没有对应的方法实现,在method_array_t的方法列表中没有该方法编号</strong></p></blockquote><blockquote><p>使用objc_msgSend消息机制,必须导入头文件 @import &lt;objc/messgae..h&gt;,让后配置<br>Build Setting–&gt;Apple LLVM 6.0 - Preprocessing–&gt;Enable Strict Checking of objc_msgSend Calls 改为 NO</p></blockquote><p>当向一个实例对象发送消息时,对象会根据super class指针找到object_class这个结构体,在这个结构体中,有一个method_array_t存储的方法列表,向对象发送消息就回去</p><p>在消息发送过程中,倘若没找到指定消息,runtime为我们预留了三次补救机会method_array_t中找是否有对应方法的实现,如果没有找到,就会沿着继承树去找,直到找到根类, 如果根类也没有对应方法实现,那么接下来就进入了我们常说的消息转发流程</p><p>消息转发机制,步骤如下图:</p><p><img src="https://github.com/ReaperLC/Hello-World/blob/master/resource/msg.png?raw=true" alt=""></p><pre class=" language-bash"><code class="language-bash">//第一次 动态方法解析+<span class="token punctuation">(</span>BOOL<span class="token punctuation">)</span>resolveInstanceMethod:<span class="token punctuation">(</span>SEL<span class="token punctuation">)</span>sel<span class="token punctuation">;</span>//第二次 快速消息转发-<span class="token punctuation">(</span>id<span class="token punctuation">)</span>forwardingTargetForSelector:<span class="token punctuation">(</span>SEL<span class="token punctuation">)</span>aSelector<span class="token punctuation">;</span>//第三次 标准消息转发 重定向-<span class="token punctuation">(</span>void<span class="token punctuation">)</span>forwardInvocation:<span class="token punctuation">(</span>NSInvocation *<span class="token punctuation">)</span>anInvocation<span class="token punctuation">;</span>//消息中转中心-<span class="token punctuation">(</span>NSMethodSignature *<span class="token punctuation">)</span>methodSignatureForSelector:<span class="token punctuation">(</span>SEL<span class="token punctuation">)</span>aSelector<span class="token punctuation">;</span></code></pre><h2 id="动态修改变量"><a href="#动态修改变量" class="headerlink" title="动态修改变量"></a>动态修改变量</h2><pre class=" language-bash"><code class="language-bash">/** 1.动态修改变量（私有变量也可修改<span class="token punctuation">)</span>*/- <span class="token punctuation">(</span>void<span class="token punctuation">)</span>dynamicModifyVariable <span class="token punctuation">{</span>    NSLog<span class="token punctuation">(</span>@<span class="token string">"修改前姓名为:%@"</span>, <span class="token punctuation">[</span>p valueForKey:@<span class="token string">"age"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    unsigned int count <span class="token operator">=</span> 0<span class="token punctuation">;</span>    // 获取类的成员变量列表<span class="token punctuation">(</span>包括私有<span class="token punctuation">)</span> 获取属性，方法，协议列表 类似    Ivar *varList <span class="token operator">=</span> class_copyIvarList<span class="token punctuation">(</span><span class="token punctuation">[</span>Person class<span class="token punctuation">]</span>, <span class="token operator">&amp;</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>int i <span class="token operator">=</span> 0<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> count<span class="token punctuation">;</span> i++<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Ivar var <span class="token operator">=</span> varList<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        const char *varName <span class="token operator">=</span> ivar_getName<span class="token punctuation">(</span>var<span class="token punctuation">)</span><span class="token punctuation">;</span>        NSString *proname <span class="token operator">=</span> <span class="token punctuation">[</span>NSString stringWithUTF8String:varName<span class="token punctuation">]</span><span class="token punctuation">;</span>        NSLog<span class="token punctuation">(</span>@<span class="token string">"查看成员变量:%@"</span>,proname<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">[</span>proname isEqualToString:@<span class="token string">"_age"</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            object_setIvar<span class="token punctuation">(</span>p, var, @<span class="token string">"22"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>//            <span class="token punctuation">[</span>p setValue:@<span class="token string">"22"</span> forKey:@<span class="token string">"age"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    NSLog<span class="token punctuation">(</span>@<span class="token string">"修改后姓名为:%@"</span>, <span class="token punctuation">[</span>p valueForKey:@<span class="token string">"age"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="动态添加方法"><a href="#动态添加方法" class="headerlink" title="动态添加方法"></a>动态添加方法</h2><p>分类不能增加方法,Extension 可以</p><pre class=" language-bash"><code class="language-bash">//1、注册方法SEL getInformationSelector <span class="token operator">=</span> sel_registerName<span class="token punctuation">(</span><span class="token string">"getPersonAllInfo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>//2、添加方法class_addMethod<span class="token punctuation">(</span><span class="token punctuation">[</span>Person class<span class="token punctuation">]</span>, getInformationSelector, <span class="token punctuation">(</span>IMP<span class="token punctuation">)</span>getInformation, <span class="token string">"v@"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="动态拦截与替换方法"><a href="#动态拦截与替换方法" class="headerlink" title="动态拦截与替换方法"></a>动态拦截与替换方法</h2><p>拦截系统自带方法的调用(Swizzle黑魔法),也可以理解为替换系统方法<br>使用场景:比如数据埋点,搜集某些页面进入次数,或者按钮点击次数,在不改变原有结构的前提下,使用拦截方法可以实现无侵入式埋点或者其他功能, 但是方法拦截需要慎重使用,可能牵一发而动全身.</p><pre class=" language-bash"><code class="language-bash">+<span class="token punctuation">(</span>void<span class="token punctuation">)</span>load <span class="token punctuation">{</span>    <span class="token punctuation">[</span>super load<span class="token punctuation">]</span><span class="token punctuation">;</span>    static dispatch_once_t onceToken<span class="token punctuation">;</span>    dispatch_once<span class="token punctuation">(</span><span class="token operator">&amp;</span>onceToken, ^<span class="token punctuation">{</span>        //获取方法名        SEL origSel <span class="token operator">=</span> @selector<span class="token punctuation">(</span>sendAction:to:forEvent:<span class="token punctuation">)</span><span class="token punctuation">;</span>        SEL swizSel <span class="token operator">=</span> @selector<span class="token punctuation">(</span>ept_sendAction:to:forEvent:<span class="token punctuation">)</span><span class="token punctuation">;</span>        Method origMethod <span class="token operator">=</span> class_getInstanceMethod<span class="token punctuation">(</span><span class="token punctuation">[</span>self class<span class="token punctuation">]</span>, origSel<span class="token punctuation">)</span><span class="token punctuation">;</span>        Method swizMethod <span class="token operator">=</span> class_getInstanceMethod<span class="token punctuation">(</span><span class="token punctuation">[</span>self class<span class="token punctuation">]</span>, swizSel<span class="token punctuation">)</span><span class="token punctuation">;</span>        //判断方法是否添加成功        BOOL addMethod <span class="token operator">=</span> class_addMethod<span class="token punctuation">(</span><span class="token punctuation">[</span>self class<span class="token punctuation">]</span>, origSel, method_getImplementation<span class="token punctuation">(</span>swizMethod<span class="token punctuation">)</span>, method_getTypeEncoding<span class="token punctuation">(</span>swizMethod<span class="token punctuation">))</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>addMethod<span class="token punctuation">)</span> <span class="token punctuation">{</span>            //替换类中已有方法的实现,如果该方法不存在添加该方法            class_replaceMethod<span class="token punctuation">(</span><span class="token punctuation">[</span>self class<span class="token punctuation">]</span>, swizSel, method_getImplementation<span class="token punctuation">(</span>origMethod<span class="token punctuation">)</span>, method_getTypeEncoding<span class="token punctuation">(</span>origMethod<span class="token punctuation">))</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>else<span class="token punctuation">{</span>            //替换Method            method_exchangeImplementations<span class="token punctuation">(</span>origMethod, swizMethod<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>- <span class="token punctuation">(</span>void<span class="token punctuation">)</span>ept_sendAction:<span class="token punctuation">(</span>SEL<span class="token punctuation">)</span>action to:<span class="token punctuation">(</span>id<span class="token punctuation">)</span>target forEvent:<span class="token punctuation">(</span>UIEvent *<span class="token punctuation">)</span>event<span class="token punctuation">{</span>    <span class="token punctuation">[</span>self ept_sendAction:action to:target forEvent:event<span class="token punctuation">]</span><span class="token punctuation">;</span>    NSLog<span class="token punctuation">(</span>@<span class="token string">"拦截系统点击方法成功,调用ept_sendAction"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>动态拦截替换方法常用函数:</p><blockquote><p><strong><font color="#2E8B57">1、class_getInstanceMethod 获取方法名<br>2、class_addMethod 判断方法是否添加成功<br>3、class_replaceMethod 替换类中已有方法的实现,如果该方法不存在添加该方法<br>4、method_exchangeImplementations 替换Method</font></strong></p></blockquote><h2 id="动态添加属性"><a href="#动态添加属性" class="headerlink" title="动态添加属性"></a>动态添加属性</h2><pre class=" language-bash"><code class="language-bash">// 重写set和get方法 设置关联- <span class="token punctuation">(</span>NSString *<span class="token punctuation">)</span>mobile <span class="token punctuation">{</span>    <span class="token keyword">return</span> objc_getAssociatedObject<span class="token punctuation">(</span>self, <span class="token string">"mobile"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>- <span class="token punctuation">(</span>void<span class="token punctuation">)</span>setMobile:<span class="token punctuation">(</span>NSString *<span class="token punctuation">)</span>mobile <span class="token punctuation">{</span>    objc_setAssociatedObject<span class="token punctuation">(</span>self, <span class="token string">"mobile"</span>, mobile, OBJC_ASSOCIATION_RETAIN_NONATOMIC<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> </code></pre><p>重写set和get方法,设置关联属性</p><blockquote><p>/*<em><br> 第一个参数:当前对象<br> 第二个参数:新增属性键值 </em>/</p></blockquote><pre class=" language-bash"><code class="language-bash">objc_getAssociatedObject<span class="token punctuation">(</span>id _Nonnull object, const void * _Nonnull key<span class="token punctuation">)</span></code></pre><blockquote><p>/*<em><br> 第一个参数id object, 当前对象<br> 第二个参数const void </em>key, 关联的key，是c字符串<br> 第三个参数id value, 被关联的对象的值<br> 第四个参数objc_AssociationPolicy policy关联引用的规则<br> */</p></blockquote><pre class=" language-bash"><code class="language-bash">objc_setAssociatedObject<span class="token punctuation">(</span>id _Nonnull object, const void * _Nonnull key,id _Nullable value, objc_AssociationPolicy policy<span class="token punctuation">)</span></code></pre><h2 id="自动化归解档"><a href="#自动化归解档" class="headerlink" title="自动化归解档"></a>自动化归解档</h2><p>归解档遵循<font color="#2E8B57">NSCoding</font>协议即可,实现归档和解档即可</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#pragma mark - coding</span>- <span class="token punctuation">(</span>void<span class="token punctuation">)</span>encodeWithCoder:<span class="token punctuation">(</span>NSCoder *<span class="token punctuation">)</span>aCoder<span class="token punctuation">;</span>- <span class="token punctuation">(</span>nullable instancetype<span class="token punctuation">)</span>initWithCoder:<span class="token punctuation">(</span>NSCoder *<span class="token punctuation">)</span>aDecoder<span class="token punctuation">;</span></code></pre><p>对于自定义类型的归解档,最原始的方法就是挨个属性去归档、解档,但是当你要归档的对象永远数亿属性资产的时候,很显然最原始的方法已经无法满足我们对于效率的诉求,从而就有了自动化归解档的诞生</p><p>分别在两个方法去遍历成员变量,取值、设值</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#pragma mark - coding</span>- <span class="token punctuation">(</span>void<span class="token punctuation">)</span>encodeWithCoder:<span class="token punctuation">(</span>NSCoder *<span class="token punctuation">)</span>aCoder<span class="token punctuation">{</span>    /**     传统做法:挨个属性去归档     但是当遇到n多属性的时候 显然一个个去归档就很繁琐了     *///    <span class="token punctuation">[</span>aCoder encodeObject:self.name forKey:@<span class="token string">"name"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>//    <span class="token punctuation">[</span>aCoder encodeObject:self.sex forKey:@<span class="token string">"sex"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>//    <span class="token punctuation">[</span>aCoder encodeObject:self.friends forKey:@<span class="token string">"friends"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    unsigned int count <span class="token operator">=</span> 0<span class="token punctuation">;</span>    Ivar *ivarList <span class="token operator">=</span> class_copyIvarList<span class="token punctuation">(</span><span class="token punctuation">[</span>Person class<span class="token punctuation">]</span>, <span class="token operator">&amp;</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>int i <span class="token operator">=</span> 0<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> count<span class="token punctuation">;</span> i ++<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Ivar ivar <span class="token operator">=</span> ivarList<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                     // 从成员列表中取出成员变量        const char *name <span class="token operator">=</span> ivar_getName<span class="token punctuation">(</span>ivar<span class="token punctuation">)</span><span class="token punctuation">;</span>       // 获取成员变量名        // 进行归档        NSString *key <span class="token operator">=</span> <span class="token punctuation">[</span>NSString stringWithUTF8String:name<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">id</span> value <span class="token operator">=</span> <span class="token punctuation">[</span>self valueForKey:key<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">[</span>aCoder encodeObject:value forKey:key<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    free<span class="token punctuation">(</span>ivarList<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>获取成员变量,赋值成员变量</p><pre class=" language-bash"><code class="language-bash">- <span class="token punctuation">(</span>nullable instancetype<span class="token punctuation">)</span>initWithCoder:<span class="token punctuation">(</span>NSCoder *<span class="token punctuation">)</span>aDecoder<span class="token punctuation">{</span>    self <span class="token operator">=</span> <span class="token punctuation">[</span>super init<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token punctuation">{</span>//        _name <span class="token operator">=</span> <span class="token punctuation">[</span>aDecoder decodeObjectForKey:@<span class="token string">"name"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>//        _sex <span class="token operator">=</span> <span class="token punctuation">[</span>aDecoder decodeObjectForKey:@<span class="token string">"sex"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>//        _friends <span class="token operator">=</span> <span class="token punctuation">[</span>aDecoder decodeObjectForKey:@<span class="token string">"friends"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        unsigned int count <span class="token operator">=</span> 0<span class="token punctuation">;</span>        Ivar *ivarList <span class="token operator">=</span> class_copyIvarList<span class="token punctuation">(</span><span class="token punctuation">[</span>Person class<span class="token punctuation">]</span>, <span class="token operator">&amp;</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>int i <span class="token operator">=</span> 0<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> count<span class="token punctuation">;</span> i++<span class="token punctuation">)</span> <span class="token punctuation">{</span>            Ivar ivar <span class="token operator">=</span> ivarList<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                        // 从成员列表中取出成员变量            const char *name <span class="token operator">=</span> ivar_getName<span class="token punctuation">(</span>ivar<span class="token punctuation">)</span><span class="token punctuation">;</span>       // 获取成员变量名            // 进行解档            NSString *key <span class="token operator">=</span> <span class="token punctuation">[</span>NSString stringWithUTF8String:name<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token function">id</span> value <span class="token operator">=</span> <span class="token punctuation">[</span>aDecoder decodeObjectForKey:key<span class="token punctuation">]</span><span class="token punctuation">;</span>            // 将值赋值给成员变量            <span class="token punctuation">[</span>self setValue:value forKey:key<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        free<span class="token punctuation">(</span>ivarList<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> self<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="字典转模型"><a href="#字典转模型" class="headerlink" title="字典转模型"></a>字典转模型</h2>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Runtime </tag>
            
            <tag> 消息机制 </tag>
            
            <tag> 消息转发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用宏定义</title>
      <link href="/2018/04/08/iOS%E5%BC%80%E5%8F%91/%E5%B8%B8%E7%94%A8%E5%AE%8F%E5%AE%9A%E4%B9%89/"/>
      <url>/2018/04/08/iOS%E5%BC%80%E5%8F%91/%E5%B8%B8%E7%94%A8%E5%AE%8F%E5%AE%9A%E4%B9%89/</url>
      
        <content type="html"><![CDATA[<h2 id="设备尺寸"><a href="#设备尺寸" class="headerlink" title="设备尺寸"></a>设备尺寸</h2><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#if __IPHONE_OS_VERSION_MAX_ALLOWED >= 80000 // 当前Xcode支持iOS8及以上</span><span class="token comment" spellcheck="true">#define SCREEN_WIDTH ([[UIScreen mainScreen] respondsToSelector:@selector(nativeBounds)]?[UIScreen mainScreen].nativeBounds.size.width/[UIScreen mainScreen].nativeScale:[UIScreen mainScreen].bounds.size.width)</span><span class="token comment" spellcheck="true">#define SCREENH_HEIGHT ([[UIScreen mainScreen] respondsToSelector:@selector(nativeBounds)]?[UIScreen mainScreen].nativeBounds.size.height/[UIScreen mainScreen].nativeScale:[UIScreen mainScreen].bounds.size.height)</span><span class="token comment" spellcheck="true">#define SCREEN_SIZE ([[UIScreen mainScreen] respondsToSelector:@selector(nativeBounds)]?CGSizeMake([UIScreen mainScreen].nativeBounds.size.width/[UIScreen mainScreen].nativeScale,[UIScreen mainScreen].nativeBounds.size.height/[UIScreen mainScreen].nativeScale):[UIScreen mainScreen].bounds.size)</span><span class="token comment" spellcheck="true">#else</span><span class="token comment" spellcheck="true">#define SCREEN_WIDTH [UIScreen mainScreen].bounds.size.width</span><span class="token comment" spellcheck="true">#define SCREENH_HEIGHT [UIScreen mainScreen].bounds.size.height</span><span class="token comment" spellcheck="true">#define SCREEN_SIZE [UIScreen mainScreen].bounds.size</span><span class="token comment" spellcheck="true">#endif</span></code></pre><h2 id="颜色设置"><a href="#颜色设置" class="headerlink" title="颜色设置"></a>颜色设置</h2><pre class=" language-bash"><code class="language-bash">/** 随机颜色 */<span class="token comment" spellcheck="true">#define LNRandomColor [UIColor colorWithRed:arc4random_uniform(256)/255.0 green:arc4random_uniform(256)/255.0 blue:arc4random_uniform(256)/255.0 alpha:1.0]</span>/** 不透明设置 */<span class="token comment" spellcheck="true">#define LNRGBColor(r, g, b) [UIColor colorWithRed:(r)/255.0 green:(g)/255.0 blue:(b)/255.0 alpha:1.0]</span>/** 带透明设置 */<span class="token comment" spellcheck="true">#define LNRGBAColor(r, g, b, a) [UIColor colorWithRed:(r)/255.0 green:(r)/255.0 blue:(r)/255.0 alpha:a]</span>/** clear背景颜色 */<span class="token comment" spellcheck="true">#define LNClearColor [UIColor clearColor]</span></code></pre><h2 id="视图设置"><a href="#视图设置" class="headerlink" title="视图设置"></a>视图设置</h2><pre class=" language-bash"><code class="language-bash">/** 设置视图圆角和边框 */<span class="token comment" spellcheck="true">#define LNViewBorderRadius(View, Radius, Width, Color)\</span>\<span class="token punctuation">[</span>View.layer setCornerRadius:<span class="token punctuation">(</span>Radius<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\<span class="token punctuation">[</span>View.layer setMasksToBounds:YES<span class="token punctuation">]</span><span class="token punctuation">;</span>\<span class="token punctuation">[</span>View.layer setBorderWidth:<span class="token punctuation">(</span>Width<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\<span class="token punctuation">[</span>View.layer setBorderColor:<span class="token punctuation">[</span>Color CGColor<span class="token punctuation">]</span><span class="token punctuation">]</span>/** 由角度转换弧度 由弧度转换角度 */<span class="token comment" spellcheck="true">#define LNDegreesToRadian(x) (M_PI * (x) / 180.0)</span><span class="token comment" spellcheck="true">#define LNRadianToDegrees(radian) (radian*180.0)/(M_PI)</span>/** 获取图片资源 */<span class="token comment" spellcheck="true">#define kLNImage(imageName) [UIImage imageNamed:[NSString stringWithFormat:@"%@",imageName]]</span></code></pre><h2 id="系统判断"><a href="#系统判断" class="headerlink" title="系统判断"></a>系统判断</h2><pre class=" language-bash"><code class="language-bash">/** 判断是否为iPhone */<span class="token comment" spellcheck="true">#define IS_IPHONE (UI_USER_INTERFACE_IDIOM() == UIUserInterfaceIdiomPhone)</span>/** 判断是否为iPad */<span class="token comment" spellcheck="true">#define IS_IPAD (UI_USER_INTERFACE_IDIOM() == UIUserInterfaceIdiomPad)</span>/** 判断是否为ipod */<span class="token comment" spellcheck="true">#define IS_IPOD ([[[UIDevice currentDevice] model] isEqualToString:@"iPod touch"])</span>/** 判断是否为 iPhone 5SE */<span class="token comment" spellcheck="true">#define iPhone5SE [[UIScreen mainScreen] bounds].size.width == 320.0f &amp;&amp; [[UIScreen mainScreen] bounds].size.height == 568.0f</span>/** 判断是否为iPhone 6/6s */<span class="token comment" spellcheck="true">#define iPhone6_6s [[UIScreen mainScreen] bounds].size.width == 375.0f &amp;&amp; [[UIScreen mainScreen] bounds].size.height == 667.0f</span>/** 判断是否为iPhone 6Plus/6sPlus */<span class="token comment" spellcheck="true">#define iPhone6Plus_6sPlus [[UIScreen mainScreen] bounds].size.width == 414.0f &amp;&amp; [[UIScreen mainScreen] bounds].size.height == 736.0f</span>/** 判断是否iphone X **/<span class="token comment" spellcheck="true">#define KISIphoneX (CGSizeEqualToSize(CGSizeMake(375.f, 812.f), [UIScreen mainScreen].bounds.size) || CGSizeEqualToSize(CGSizeMake(812.f, 375.f), [UIScreen mainScreen].bounds.size))</span>/** 获取系统版本 */<span class="token comment" spellcheck="true">#define IOS_SYSTEM_VERSION [[[UIDevice currentDevice] systemVersion] floatValue]</span>/** 判断 iOS 8 或更高的系统版本 */<span class="token comment" spellcheck="true">#define IOS_VERSION_8_OR_LATER (([[[UIDevice currentDevice] systemVersion] floatValue] >=8.0)? (YES):(NO))</span>/** 判断是真机还是模拟器 */<span class="token comment" spellcheck="true">#if TARGET_OS_IPHONE</span>//iPhone Device<span class="token comment" spellcheck="true">#endif</span><span class="token comment" spellcheck="true">#if TARGET_IPHONE_SIMULATOR</span>//iPhone Simulator<span class="token comment" spellcheck="true">#endif</span></code></pre><h2 id="沙盒操作"><a href="#沙盒操作" class="headerlink" title="沙盒操作"></a>沙盒操作</h2><pre class=" language-bash"><code class="language-bash">/** 获取temp */<span class="token comment" spellcheck="true">#define kPathTemp NSTemporaryDirectory()</span>/** 获取沙盒 Document */<span class="token comment" spellcheck="true">#define kPathDocument [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject]</span>/** 获取沙盒 Cache */<span class="token comment" spellcheck="true">#define kPathCache [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) firstObject]</span></code></pre><h2 id="GCD常用"><a href="#GCD常用" class="headerlink" title="GCD常用"></a>GCD常用</h2><pre class=" language-bash"><code class="language-bash">/** GCD - 一次性执行 */<span class="token comment" spellcheck="true">#define kDISPATCH_ONCE_BLOCK(onceBlock) static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, onceBlock);</span>/** GCD - 在Main线程上运行 */<span class="token comment" spellcheck="true">#define kDISPATCH_MAIN_THREAD(mainQueueBlock) dispatch_async(dispatch_get_main_queue(), mainQueueBlock);</span>/** GCD - 开启异步线程 */<span class="token comment" spellcheck="true">#define kDISPATCH_GLOBAL_QUEUE_DEFAULT(globalQueueBlock) dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), globalQueueBlocl);</span></code></pre><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#define LNWeakSelf(type)  __weak typeof(type) weaktype = type;</span><span class="token comment" spellcheck="true">#define LNStrongSelf(type)  __strong typeof(type) type = weaktype;</span>/** 获取通知中心 */<span class="token comment" spellcheck="true">#define LNNotificationCenter [NSNotificationCenter defaultCenter]</span>/** 自定义log */<span class="token comment" spellcheck="true">#ifdef DEBUG</span><span class="token comment" spellcheck="true">#define LNLog(...) NSLog(@"%s 第%d行 \n %@\n\n",__func__,__LINE__,[NSString stringWithFormat:__VA_ARGS__])</span><span class="token comment" spellcheck="true">#else</span><span class="token comment" spellcheck="true">#define LNLog(...)</span><span class="token comment" spellcheck="true">#endif</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 宏定义 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数式、链式语法</title>
      <link href="/2018/04/02/iOS%E5%BC%80%E5%8F%91/%E5%87%BD%E6%95%B0%E5%BC%8F%E3%80%81%E9%93%BE%E5%BC%8F%E8%AF%AD%E6%B3%95/"/>
      <url>/2018/04/02/iOS%E5%BC%80%E5%8F%91/%E5%87%BD%E6%95%B0%E5%BC%8F%E3%80%81%E9%93%BE%E5%BC%8F%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>#函数式、链式语法</p><p><strong>Person.h</strong></p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#import &lt;Foundation/Foundation.h></span>@interface Person <span class="token keyword">:</span> NSObject/** 传统写法 */- <span class="token punctuation">(</span>void<span class="token punctuation">)</span>eat<span class="token punctuation">;</span>- <span class="token punctuation">(</span>void<span class="token punctuation">)</span>sleep<span class="token punctuation">;</span>/** 使用‘<span class="token punctuation">[</span><span class="token punctuation">]</span>’连续调用 */- <span class="token punctuation">(</span>Person *<span class="token punctuation">)</span>eat1<span class="token punctuation">;</span>- <span class="token punctuation">(</span>Person *<span class="token punctuation">)</span>sleep1<span class="token punctuation">;</span>/** 使用‘<span class="token punctuation">(</span><span class="token punctuation">)</span>’函数式编程,block实现 */- <span class="token punctuation">(</span>void<span class="token punctuation">(</span>^<span class="token punctuation">)</span><span class="token punctuation">(</span>void<span class="token punctuation">))</span>eat2<span class="token punctuation">;</span>- <span class="token punctuation">(</span>void<span class="token punctuation">(</span>^<span class="token punctuation">)</span><span class="token punctuation">(</span>void<span class="token punctuation">))</span>sleep2<span class="token punctuation">;</span>/** 使用函数式 + 链式 无参 */- <span class="token punctuation">(</span>Person *<span class="token punctuation">(</span>^<span class="token punctuation">)</span><span class="token punctuation">(</span>void<span class="token punctuation">))</span>eat3<span class="token punctuation">;</span>- <span class="token punctuation">(</span>Person *<span class="token punctuation">(</span>^<span class="token punctuation">)</span><span class="token punctuation">(</span>void<span class="token punctuation">))</span>sleep3<span class="token punctuation">;</span>/** 函数式 + 链式 带参 */- <span class="token punctuation">(</span>Person * <span class="token punctuation">(</span>^<span class="token punctuation">)</span><span class="token punctuation">(</span>NSString *foodName<span class="token punctuation">))</span>eat4<span class="token punctuation">;</span>- <span class="token punctuation">(</span>Person * <span class="token punctuation">(</span>^<span class="token punctuation">)</span><span class="token punctuation">(</span>NSInteger hour<span class="token punctuation">))</span>sleep4<span class="token punctuation">;</span>@end</code></pre><p><strong>Person.m</strong></p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#import "Person.h"</span>@implementation Person<span class="token comment" spellcheck="true">#pragma mark - 传统写法,单独调用,不能任意顺序组合</span>- <span class="token punctuation">(</span>void<span class="token punctuation">)</span>eat <span class="token punctuation">{</span>    NSLog<span class="token punctuation">(</span>@<span class="token string">"%s"</span>,__func__<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>-<span class="token punctuation">(</span>void<span class="token punctuation">)</span>sleep <span class="token punctuation">{</span>    NSLog<span class="token punctuation">(</span>@<span class="token string">"%s"</span>,__func__<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">#pragma mark - 使用‘[]’实现连续调用</span>- <span class="token punctuation">(</span>Person *<span class="token punctuation">)</span>eat1 <span class="token punctuation">{</span>    NSLog<span class="token punctuation">(</span>@<span class="token string">"%s"</span>,__func__<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> self<span class="token punctuation">;</span><span class="token punctuation">}</span>-<span class="token punctuation">(</span>Person *<span class="token punctuation">)</span>sleep1<span class="token punctuation">{</span>    NSLog<span class="token punctuation">(</span>@<span class="token string">"%s"</span>,__func__<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> self<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">#pragma mark - 使用‘()’函数式编程,block实现</span>-<span class="token punctuation">(</span>void <span class="token punctuation">(</span>^<span class="token punctuation">)</span><span class="token punctuation">(</span>void<span class="token punctuation">))</span>eat2 <span class="token punctuation">{</span>    //定义block    void <span class="token punctuation">(</span>^eat2Block<span class="token punctuation">)</span><span class="token punctuation">(</span>void<span class="token punctuation">)</span> <span class="token operator">=</span> ^ <span class="token punctuation">{</span>        NSLog<span class="token punctuation">(</span>@<span class="token string">"%s"</span>,__FUNCTION__<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> eat2Block<span class="token punctuation">;</span><span class="token punctuation">}</span>-<span class="token punctuation">(</span>void <span class="token punctuation">(</span>^<span class="token punctuation">)</span><span class="token punctuation">(</span>void<span class="token punctuation">))</span>sleep2 <span class="token punctuation">{</span>    //定义block    void <span class="token punctuation">(</span>^sleep2Block<span class="token punctuation">)</span><span class="token punctuation">(</span>void<span class="token punctuation">)</span> <span class="token operator">=</span> ^ <span class="token punctuation">{</span>        NSLog<span class="token punctuation">(</span>@<span class="token string">"%s"</span>,__FUNCTION__<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> sleep2Block<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">#pragma mark - 使用函数式 + 链式 无参</span>-<span class="token punctuation">(</span>Person *<span class="token punctuation">(</span>^<span class="token punctuation">)</span><span class="token punctuation">(</span>void<span class="token punctuation">))</span>eat3<span class="token punctuation">{</span>    Person *<span class="token punctuation">(</span>^eat3Block<span class="token punctuation">)</span><span class="token punctuation">(</span>void<span class="token punctuation">)</span> <span class="token operator">=</span> ^<span class="token punctuation">{</span>        NSLog<span class="token punctuation">(</span>@<span class="token string">"%s"</span>,__FUNCTION__<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> self<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> eat3Block<span class="token punctuation">;</span><span class="token punctuation">}</span>-<span class="token punctuation">(</span>Person *<span class="token punctuation">(</span>^<span class="token punctuation">)</span><span class="token punctuation">(</span>void<span class="token punctuation">))</span>sleep3<span class="token punctuation">{</span>    Person *<span class="token punctuation">(</span>^sleep3Block<span class="token punctuation">)</span><span class="token punctuation">(</span>void<span class="token punctuation">)</span> <span class="token operator">=</span> ^<span class="token punctuation">{</span>        NSLog<span class="token punctuation">(</span>@<span class="token string">"%s"</span>,__FUNCTION__<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> self<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> sleep3Block<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">#pragma mark - 函数式 + 链式 带参</span>- <span class="token punctuation">(</span>Person *<span class="token punctuation">(</span>^<span class="token punctuation">)</span><span class="token punctuation">(</span>NSString *<span class="token punctuation">))</span>eat4<span class="token punctuation">{</span>    Person * <span class="token punctuation">(</span>^eat4Block<span class="token punctuation">)</span><span class="token punctuation">(</span>NSString *<span class="token punctuation">)</span> <span class="token operator">=</span> ^<span class="token punctuation">(</span>NSString *foodName<span class="token punctuation">)</span> <span class="token punctuation">{</span>        NSLog<span class="token punctuation">(</span>@<span class="token string">"这个人吃了: %@"</span>,foodName<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> self<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> eat4Block<span class="token punctuation">;</span><span class="token punctuation">}</span>//上下两种写法一样- <span class="token punctuation">(</span>Person *<span class="token punctuation">(</span>^<span class="token punctuation">)</span><span class="token punctuation">(</span>NSInteger<span class="token punctuation">))</span>sleep4<span class="token punctuation">{</span>    <span class="token keyword">return</span> ^<span class="token punctuation">(</span>NSInteger hour<span class="token punctuation">)</span> <span class="token punctuation">{</span>        NSLog<span class="token punctuation">(</span>@<span class="token string">"然后睡了%ld小时"</span>,<span class="token punctuation">(</span>long<span class="token punctuation">)</span>hour<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> self<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span>@end</code></pre>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链式 </tag>
            
            <tag> 函数 </tag>
            
            <tag> 点语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实用框架</title>
      <link href="/2018/04/02/iOS%E5%BC%80%E5%8F%91/%E5%AE%9E%E7%94%A8%E6%A1%86%E6%9E%B6/"/>
      <url>/2018/04/02/iOS%E5%BC%80%E5%8F%91/%E5%AE%9E%E7%94%A8%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="新闻选项卡"><a href="#新闻选项卡" class="headerlink" title="新闻选项卡"></a>新闻选项卡</h2><p>1.新闻类的顶部选项卡类似网易新闻：WMPageController，HMSegmentControl，HTHorizontalSelectionList</p><p>这三者我跟推荐第一种，第一种有很多手势，比如点击顶部列表会滑动到最顶端。具体使用方法请参考<a href="https://github.com/wangmchn/WMPageController" target="_blank" rel="noopener">点击打开链接</a></p><h2 id="自定义tabbar"><a href="#自定义tabbar" class="headerlink" title="自定义tabbar"></a>自定义tabbar</h2><p>2.自定义tabbar：CYLTabBarController</p><p>闲鱼和转转这两个app相信大部分人都用过，他们的tabbar是不是很有特色呢，想拥有和他们一样的效果就使用这个框架。具体使用方法请参考点击<a href="https://github.com/ChenYilong/CYLTabBarController" target="_blank" rel="noopener">打开链接</a></p><h2 id="抽屉效果"><a href="#抽屉效果" class="headerlink" title="抽屉效果"></a>抽屉效果</h2><p>3.抽屉效果：MMDrawerController，RESideMenu</p><p>很多app需要做成侧边栏菜单栏的抽屉效果，这时候你就可以选择MMDrawerController，具体使用方法请参考点击<a href="https://github.com/mutualmobile/MMDrawerController" target="_blank" rel="noopener">打开链接</a></p><h2 id="字典转模型"><a href="#字典转模型" class="headerlink" title="字典转模型"></a>字典转模型</h2><p>4.KVC键值对编码常用来字典和模型互转：MJExtension，Mantle，JsonModel</p><p>这三者都很好用，我比较常用MJExtension，耦合性低不需要继承，直接用就行，具体使用方法请参考点击<a href="https://github.com/CoderMJLee/MJExtension" target="_blank" rel="noopener">打开链接</a></p><h2 id="指示层"><a href="#指示层" class="headerlink" title="指示层"></a>指示层</h2><p>5.透明指示层：MBProgressHUD，SVProgressHUD</p><p>这两者是当前最常使用的，不过我更倾向于第一种，具体使用方法请参考点击<a href="https://github.com/jdg/MBProgressHUD" target="_blank" rel="noopener">打开链接</a></p><h2 id="键盘遮挡"><a href="#键盘遮挡" class="headerlink" title="键盘遮挡"></a>键盘遮挡</h2><p>6.避免键盘遮挡输入框：TPKeyboardAvoiding</p><p>有了这个框架，我们再也不用监听键盘的升起落下了。具体使用方法请参考点击<a href="https://github.com/michaeltyson/TPKeyboardAvoiding" target="_blank" rel="noopener">打开链接</a></p><h2 id="网络请求"><a href="#网络请求" class="headerlink" title="网络请求"></a>网络请求</h2><p>7.网络请求的框架：AFNetworking，YTKNetworking</p><p>相信只要是做iOS开发的都知道AFN，但是AFN使用起来还是有点繁琐，所以我推荐大家使用YTKNetworking（基于AFN的封装），具体使用方法请参考点击<a href="https://github.com/yuantiku/YTKNetwork" target="_blank" rel="noopener">打开链接</a></p><h2 id="图表"><a href="#图表" class="headerlink" title="图表"></a>图表</h2><p>8.图表：Charts，MPAndroidChart</p><p>Charts这个框架是根据MPAndroidChart改的，Charts是用Swift语言写的，MPAndroidChart是用java语言写的，有柱状图，饼图，雷达图等等，具体使用方法请参考点击<a href="https://github.com/danielgindi/Charts" target="_blank" rel="noopener">打开链接</a></p><h2 id="适配"><a href="#适配" class="headerlink" title="适配"></a>适配</h2><p>9.屏幕适配：Masonry，SnapKit，HandyAutoLayout</p><p>我常用Masonry做屏幕适配，其他两个也挺多人用，关于Masonry使用请参考点击<a href="https://github.com/SnapKit/Masonry" target="_blank" rel="noopener">打开链接</a></p><h2 id="JS原生交互"><a href="#JS原生交互" class="headerlink" title="JS原生交互"></a>JS原生交互</h2><p>10.JavaScript与ObjectiveC之间发送消息：WebViewJavaScriptBridge</p><p>用于JS与OC交互时使用，请参考点击<a href="https://github.com/marcuswestin/WebViewJavascriptBridge" target="_blank" rel="noopener">打开链接</a>。提到这个顺便说下JSPatch与JSPatchConvertor，前者是可以用JavaScript语言编写原生iOSapp，后者是将OC语言的代码转成JavaScript语言</p><h2 id="cell行号"><a href="#cell行号" class="headerlink" title="cell行号"></a>cell行号</h2><p>11.计算tableViewCell的行号：UITableView-FDTemplateLayoutCell</p><p>有时我们需要根据cell里的数据来计算cell的高度，实现起来比较困难，此时就可以用这个框架啦，使用参考点击<a href="https://github.com/forkingdog/UITableView-FDTemplateLayoutCell" target="_blank" rel="noopener">打开链接</a></p><h2 id="AR"><a href="#AR" class="headerlink" title="AR"></a>AR</h2><p>12.ARSegmentPager</p><p>a fully custom UITabbarController-likely controller with parallax header，使用参考点击<a href="https://github.com/AugustRush/ARSegmentPager" target="_blank" rel="noopener">打开链接</a></p><h2 id="弹窗"><a href="#弹窗" class="headerlink" title="弹窗"></a>弹窗</h2><p>13.WYPopoverController</p><p>当前内容的弹框，使用参考点击<a href="https://github.com/nicolaschengdev/WYPopoverController" target="_blank" rel="noopener">打开链接</a></p><h2 id="富文本"><a href="#富文本" class="headerlink" title="富文本"></a>富文本</h2><p>14.用来编辑富文本：YYText，TTTAttributedLabel</p><p>这两个框架可以结合使用，都是用于富文本问题</p><h2 id="webView加载进度"><a href="#webView加载进度" class="headerlink" title="webView加载进度"></a>webView加载进度</h2><p>15.显示webView的加载进度：NJKWebViewProgress</p><p>使用请参考点击<a href="https://github.com/ninjinkun/NJKWebViewProgress" target="_blank" rel="noopener">打开链接</a></p><h2 id="SAMKeychain"><a href="#SAMKeychain" class="headerlink" title="SAMKeychain"></a>SAMKeychain</h2><p>16.SAMKeychain</p><p>使用参考点击<a href="https://github.com/soffes/SAMKeychain" target="_blank" rel="noopener">打开链接</a></p><h2 id="三级联动pickView"><a href="#三级联动pickView" class="headerlink" title="三级联动pickView"></a>三级联动pickView</h2><p>17.三级联动的pickview以及时间选择等等：ActionSheetPicker-3.0</p><p>使用参考点击<a href="https://github.com/skywinder/ActionSheetPicker-3.0" target="_blank" rel="noopener">打开链接</a></p><h2 id="下拉水滴"><a href="#下拉水滴" class="headerlink" title="下拉水滴"></a>下拉水滴</h2><p>18.下拉刷新水滴动画：ODRefreshControl</p><p>使用参考点击<a href="https://github.com/Sephiroth87/ODRefreshControl" target="_blank" rel="noopener">打开链接</a></p><h2 id="轮播"><a href="#轮播" class="headerlink" title="轮播"></a>轮播</h2><p>19.轮播图：SDCycleScrollView</p><p>使用参考点击<a href="https://github.com/gsdios/SDCycleScrollView" target="_blank" rel="noopener">打开链接</a></p><p>1、使用XML请求SOAP，用NSURLConnectionDelegate实现</p><p>   <a href="http://www.webxml.com.cn/zh_cn/web_services.aspx" target="_blank" rel="noopener">可用接口</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码 </tag>
            
            <tag> 第三方 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS转场动画-让你的页面app不再单调</title>
      <link href="/2018/03/23/iOS%E5%BC%80%E5%8F%91/fromView%20and%20toView/"/>
      <url>/2018/03/23/iOS%E5%BC%80%E5%8F%91/fromView%20and%20toView/</url>
      
        <content type="html"><![CDATA[<h1 id="fromView-and-toView"><a href="#fromView-and-toView" class="headerlink" title="fromView and toView"></a>fromView and toView</h1><p>转场动画中时常会出现 fromView 和 toView 这一组相对的概念</p><p>fromView:跳转前的视图<br>toView：跳转后的视图</p><p>当然这两个视图是相对的，<br>比如A present to B ,此时 A =  fromView , B = toView<br>然而B dismiss to A ,此时 B =  fromView , A = toView<br>所以fromView和toView不是固定且一成不变的，会随着动画的执行和结束发生变化，扮演不同的角色</p><h1 id="presentedViewController-and-presentingViewController"><a href="#presentedViewController-and-presentingViewController" class="headerlink" title="presentedViewController and presentingViewController"></a>presentedViewController and presentingViewController</h1><p>听过  fromView 和 toView ，想必  presentedViewController 和 presentingViewController也不会太陌生，这也是一组相对概念，而且容易与第一组混淆。</p><p>不同之处在于  presentedViewController 和 presentingViewController  的身份不受present影响，简单说还是上面的例子<br>比如A present to B ,此时 A = presentedViewController , B = presentingViewController<br>然而B dismiss to A ,此时 A = presentedViewController , B = presentingViewController</p><h1 id="modalPresentationStyle"><a href="#modalPresentationStyle" class="headerlink" title="modalPresentationStyle"></a>modalPresentationStyle</h1><p>系统提供的一个present时动画的枚举类型</p><pre><code>typedef NS_ENUM(NSInteger, UIModalPresentationStyle) {        UIModalPresentationFullScreen = 0,        UIModalPresentationPageSheet NS_ENUM_AVAILABLE_IOS(3_2) __TVOS_PROHIBITED,        UIModalPresentationFormSheet NS_ENUM_AVAILABLE_IOS(3_2) __TVOS_PROHIBITED,        UIModalPresentationCurrentContext NS_ENUM_AVAILABLE_IOS(3_2),        UIModalPresentationCustom NS_ENUM_AVAILABLE_IOS(7_0),        UIModalPresentationOverFullScreen NS_ENUM_AVAILABLE_IOS(8_0),        UIModalPresentationOverCurrentContext NS_ENUM_AVAILABLE_IOS(8_0),        UIModalPresentationPopover NS_ENUM_AVAILABLE_IOS(8_0) __TVOS_PROHIBITED,        UIModalPresentationBlurOverFullScreen __TVOS_AVAILABLE(11_0) __IOS_PROHIBITED __WATCHOS_PROHIBITED,        UIModalPresentationNone NS_ENUM_AVAILABLE_IOS(7_0) = -1,};</code></pre><p>其中可以自定义动画效果的只有两种：FullScreen和Custom，两者的区别在于FullScreen会移除fromView，而Custom不会。</p><h1 id="UIViewControllerTransitioningDelegate"><a href="#UIViewControllerTransitioningDelegate" class="headerlink" title="UIViewControllerTransitioningDelegate"></a>UIViewControllerTransitioningDelegate</h1><h1 id="transitionFromViewController"><a href="#transitionFromViewController" class="headerlink" title="transitionFromViewController"></a>transitionFromViewController</h1><p>通常的使用场景是 在多个Child ViewController之间切换.</p><pre><code>[self transitionFromViewController:<#(nonnull uiviewcontroller="" *)#="">                      toViewController:<#(nonnull uiviewcontroller="" *)#="">                              duration:<#(nstimeinterval)#>                               options:<#(uiviewanimationoptions)#>                            animations:<#^(void)animations#>                            completion:<#^(bool finished)completion#="">];                            </#^(bool></#^(void)animations#></#(uiviewanimationoptions)#></#(nstimeinterval)#></#(nonnull></#(nonnull></code></pre>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>UICollectionView Layout自定义 Layout布局</title>
      <link href="/2018/03/02/iOS%E5%BC%80%E5%8F%91/UICollectionView%20Layout%E8%87%AA%E5%AE%9A%E4%B9%89%20Layout%E5%B8%83%E5%B1%80/"/>
      <url>/2018/03/02/iOS%E5%BC%80%E5%8F%91/UICollectionView%20Layout%E8%87%AA%E5%AE%9A%E4%B9%89%20Layout%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<p>UICollectionView Layout自定义 Layout布局</p><p>#前言</p><h3 id="要从容地着手去做一件事-但一旦开始-就要坚持到底。——比阿斯【美】"><a href="#要从容地着手去做一件事-但一旦开始-就要坚持到底。——比阿斯【美】" class="headerlink" title="要从容地着手去做一件事,但一旦开始,就要坚持到底。——比阿斯【美】"></a><strong>要从容地着手去做一件事,但一旦开始,就要坚持到底。——比阿斯【美】</strong></h3><p>对于UIcollectionView的基础使用相信各位早已烂熟于心，那么对于UICollectionView Layout自定义布局呢？你知道多少？当我们使用系统自带的UICollectionViewFlowLayout无法实现我们的布局时，我们就不得不考虑自定义layout。现将自定义布局规为以下三部曲：</p><ul><li><p>覆写prepareLayout方法，并在里面事先就计算好必要的布局信息并存储起来，初始化。</p></li><li><p>基于prepareLayout方法中的布局信息，使用collectionViewContentSize方法返回UICollectionView的内容尺寸。</p></li><li><p>使用layoutAttributesForElementsInRect:方法返回指定区域cell、Supplementary View和Decoration View的布局属性。</p></li></ul><h1 id="重写PrepareLayout"><a href="#重写PrepareLayout" class="headerlink" title="重写PrepareLayout"></a>重写PrepareLayout</h1><h1 id="重写collectionViewContentSize"><a href="#重写collectionViewContentSize" class="headerlink" title="重写collectionViewContentSize"></a>重写collectionViewContentSize</h1><h1 id="重写layoutAttributesForElementsInRect"><a href="#重写layoutAttributesForElementsInRect" class="headerlink" title="重写layoutAttributesForElementsInRect"></a>重写layoutAttributesForElementsInRect</h1><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>前人栽树，后人乘凉，开发道路上已经有各位大佬为我们趟过雷，剩下的就是需要我们自己去吸收，去探索那些遗留的雷区，谁能发现，当然就会成为造福人类的英雄了。</p><p>1、<a href="https://www.jianshu.com/p/cabec2786241?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation" target="_blank" rel="noopener">详细分享UICollectionView的自定义布局(瀑布流, 线性, 圆形…)</a><br>2、<a href="https://www.jianshu.com/p/83f2d6ac7e68" target="_blank" rel="noopener">自定义布局和自定义流水布局（CollectionViewLayout和CollectionViewFlowLayout）</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>基础讲解</title>
      <link href="/2018/01/22/iOS%E5%BC%80%E5%8F%91/15165912880700/"/>
      <url>/2018/01/22/iOS%E5%BC%80%E5%8F%91/15165912880700/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.jianshu.com/p/56e40ea56813" target="_blank" rel="noopener">集锦</a><br><a href="https://www.cnblogs.com/jukaiit/p/7932313.html" target="_blank" rel="noopener">解答</a></p><p>1、为什么说Objective-C是一门动态的语言？</p><pre><code>这里动态语言指的是不需要在编译时确定所有的东西，在运行时还可以动态的添加变量、方法和类。Objective-C 可以通过Runtime 这个运行时机制，在运行时确定类或者变量的类型，动态的添加变量、方法、类等，所以说Objective-C 是一门动态的语言。</code></pre><p>2、讲一下MVC和MVVM，MVP？</p><pre><code>  MVC ：  简单来说就是逻辑、试图、数据进行分层，实现解耦。最早存在于桌面程序中的, M是指业务          数据, V是指用户界面, C则是控制器在具体的业务场景中, C作为M和V之间的连接, 负责获          取输入的业务数据,然后将处理后的数据输出到界面上做相应展示, 另外, 在数据有所更新          时, C还需要及时提交相应更新到界面展示. 在上述过程中, 因为M和V之间是完全隔离的,           所以在业务场景切换时, 通常只需要替换相应的C, 复用已有的M和V便可快速搭建新的业务          场景.   MVVM： 由视图(View)、视图模型(ViewModel)、模型(Model)三部分组成，将一部分逻辑(耗时，         公共方法，网络请求等)和数据的处理等操作从控制器里面搬运到ViewModel中</code></pre><p>3、为什么代理要用weak？代理的delegate和dataSource有什么区别？block和代理的区别?</p><pre><code>weak:  指明该对象并不负责保持delegate这个对象，delegate这个对象的销毁由外部控制,防止循环引用。delegate:偏重于与用户交互的回调，有那些方法可以供我使用dataSource:偏重于数据的回调delegate是操作，datasource是数据**block与代理**1、都是进行单一回调，2、delegate是个对象，然后用过一个对象自己调用代理协议函数来完成整个流程。block是传递一个函   数指针，利用函数指针执行来进行回调。3、在内存管理上，delegate不需要保存引用。block对引用数据有copy的处理。</code></pre><p>4、属性的实质是什么？包括哪几个部分？属性默认的关键字都有哪些？@dynamic关键字和@synthesize关键字是用来做什么的？</p><pre><code>@property = 实例变量 + get方法 + set方法  （因此使用property会自动生成get和set）readwrite，assign, atomic;@synthesize和@dynamic区别, 在声明property属性后，有2种实现选择:@synthesize编译器期间，让编译器自动生成getter/setter方法。当有自定义的存或取方法时，自定义会屏蔽自动生成该方法@dynamic告诉编译器，不自动生成getter/setter方法，避免编译期间产生警告，然后由自己实现存取方法。或存取方法在运行时动态创建绑定：主要使用在CoreData的实现NSManagedObject子类时使用，由Core Data框架在程序运行的时动态生成子类属性 </code></pre><p>5、属性的默认关键字是什么？</p><pre><code>对于基本数据类型默认关键字是atomic,readwrite,assign对于普通的OC对象atomic,readwrite,strong    </code></pre><p>6、NSString为什么要用copy关键字，如果用strong会有什么问题？（注意：这里没有说用strong就一定不行。使用copy和strong是看情况而定</p><table><thead><tr><th>属性关键字</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td>strong</td><td style="text-align:center">在赋值时调用被指向对象的retain方法，使其引用计数加1</td></tr><tr><td>weak</td><td style="text-align:center">不增加对象的引用计数，不持有对象，对象消失，指针自动变为nil</td></tr><tr><td>assign</td><td style="text-align:center">只用来修饰基础数据类型（int double等），不改变引用计数</td></tr><tr><td>copy</td><td style="text-align:center">建立一个引用计数为1的对象，通常用于NSString和block</td></tr><tr><td>atomic</td><td style="text-align:center">原子操作，提供线程安全，默认属性，耗费系统资源</td></tr><tr><td>nonatomic</td><td style="text-align:center">非原子操作，不提供线程安全，效率更高</td></tr><tr><td>readonly</td><td style="text-align:center">只读属性</td></tr><tr><td>readwrite</td><td style="text-align:center">读写属性，默认</td></tr><tr><td>unsafe_unretained</td><td style="text-align:center">类似weak,但引用计数为0，指针不会nil</td></tr></tbody></table><p>7、如何令自己所写的对象具有拷贝功能?</p><pre><code>具体步骤：1、需声明该类遵从 NSCopying 协议2、实现 NSCopying 协议。该协议只有一个方法:- (id)copyWithZone:(NSZone *)zone;注意：一提到让自己的类用 copy 修饰符，我们总是想覆写copy方法，其实真正需要实现的却是 “copyWithZone” 方法。</code></pre><p>8、可变集合类 和 不可变集合类的 copy 和 mutablecopy有什么区别？如果是集合是内容复制的话，集合里面的元素也是内容复制么？</p><p>9、为什么IBOutlet修饰的UIView也适用weak关键字？</p><pre><code>因为当我们将控件拖到Storyboard上，相当于新创建了一个对象，而这个对象是加到视图控制器的view上，view有一个subViews属性，这个属性是一个数组，里面是这个view的所有子view，而我们加的控件就位于这个数组中，那么说明，实际上我们的控件对象是属于view的，也就是说view对加到它上面的控件是强引用。当我们使用Outlet属性的时候，我们是在viewController里面使用，而这个Outlet属性是有view来进行强引用的，我们在viewController里面仅仅是对其使用，并没有必要拥有它，所以是weak的</code></pre><p>10、nonatomic和atomic的区别？atomic是绝对的线程安全么？为什么？如果不是，那应该如何实现？</p><pre><code> nonatomic的内存管理语义是非原子性的，非原子性的操作本来就是线程不安全，而atomic的操作是原 子性的，但并不意味着他就是线程安全的，它会增加正确的几率，能够更好的避免线程错误，但仍旧是不 安全的。</code></pre><p>11、UICollectionView自定义layout如何实现？</p><p>12、用StoryBoard开发界面有什么弊端？如何避免？</p><pre><code> 1、难以维护 2、性能瓶颈 3、错误定位困难</code></pre><p>13、进程和线程的区别？同步异步的区别？并行和并发的区别？</p><pre><code>进程和线程: 同步和异步:并行(parallellism)和并发(concurrency)</code></pre><p>14、线程间通信？</p><p>15、GCD的一些常用的函数？（group，barrier，信号量，线程同步）</p><p>16、如何使用队列来避免资源抢夺？</p><p>17、数据持久化的几个方案（fmdb用没用过）</p><pre><code>plist文件（属性列表）preference（偏好设置）NSKeyedArchiver（归档）SQLite 3CoreData</code></pre><p>18、说一下AppDelegate的几个方法？从后台到前台调用了哪些方法？第一次启动调用了哪些方法？从前台到后台调用了哪些方法？<br>1、 <strong>– (BOOL)application:(UIApplication )application didFinishLaunchingWithOptions:<br> (NSDictionary )launchOptions NS_AVAILABLE_IOS(3_0);</strong></p><pre><code>当应用程序启动时（不包括已在后台的情况下转到前台），调用此回调。launchOptions是启动参数，假如用户通过点击push通知启动的应用，这个参数里会存储一些push通知的信息。</code></pre><p>2、 <strong>– (void)applicationDidBecomeActive:(UIApplication *)application;</strong></p><pre><code> // Restart any tasks that were paused (or not yet started) while the  application was inactive. If the application was previously in the  background, optionally refresh the user interface.当应用程序全新启动，或者在后台转到前台，完全激活时，都会调用这个方法。如果应用程序是以前运行在后台，这时可以选择刷新用户界面。</code></pre><p>3、 <strong>– (void)applicationDidEnterBackground:(UIApplication *)application NS_AVAILABLE_IOS(4_0);</strong></p><pre><code> // Use this method to release shared resources, save user data, invalidate  timers, and store enough application state information to restore your  application to its current state in case it is terminated later.// If your application supports background execution, this method is called instead of applicationWillTerminate: when the user quits.当用户从前台状态转入后台时，调用此方法。使用此方法来释放资源共享，保存用户数据，无效计时器，并储存足够的应用程序状态信息的情况下被终止后，将应用 程序恢复到目前的状态。如果您的应用程序支持后台运行，这种方法被调用，否则调用applicationWillTerminate：用户退出。</code></pre><p>4、<strong>– (void)applicationWillEnterForeground:(UIApplication *)application NS_AVAILABLE_IOS(4_0);</strong></p><pre><code>// Called as part of the transition from the background to the inactive state; here you can undo many of the changes made on entering the background.当应用在后台状态，将要进行动前台运行状态时，会调用此方法。如果应用不在后台状态，而是直接启动，则不会回调此方法。从后台到前台2, 4; 第一次启动1, 2; 从前台到后台3;</code></pre><p>19、NSCache优于NSDictionary的几点？</p><pre><code>NSCache胜过NSDictionary之处在于，当系统资源将要耗尽时，它可以自动删减缓存。如果采用普通的字典，那么就要自己编写挂钩，在系统发出“低内存”通知时手工删减缓存。NSCache并不会“拷贝”键，而是会“保留”它。此行为用NSDictionary也可以实现，然而需要编写相当复杂的代码。NSCache对象不拷贝键的原因在于：很多时候，键都是不支持拷贝操作的对象来充当的。因此，NSCache不会自动拷贝键，所以说，在键不支持拷贝操作的情况下，该类用起来比字典更方便。另外，NSCache是线程安全的，而NSDictionary则绝对不具备此优势</code></pre><p>20、知不知道Designated Initializer？使用它的时候有什么需要注意的问题？</p><p>21、实现description方法能取到什么效果？</p><p>22、objc使用什么机制管理对象内存？</p><p>中级Block</p><p>1、block的实质是什么？一共有几种block？都是什么情况下生成的？</p><p>   结构体</p><pre><code>struct Block_descriptor {    unsigned long int reserved;    unsigned long int size;    void (*copy)(void *dst, void *src);    void (*dispose)(void *);};struct Block_layout {    void *isa;    int flags;    int reserved;     void (*invoke)(void *, ...);    struct Block_descriptor *descriptor;    /* Imported variables. */};根据isa指针，block一共有3种类型的block_NSConcreteGlobalBlock 全局静态_NSConcreteStackBlock  保存在栈中，出函数作用域就销毁_NSConcreteMallocBlock 保存在堆中，retainCount == 0销毁而ARC和MRC中，还略有不同;</code></pre><p>2、为什么在默认情况下无法修改被block捕获的变量？ __block都做了什么？</p><p>3、模拟一下循环引用的一个情况？block实现界面反向传值如何实现？</p><p>Runtime</p><blockquote><p>1、objc在向一个对象发送消息时，发生了什么？</p></blockquote><p>2、什么时候会报unrecognized selector错误？iOS有哪些机制来避免走到这一步？</p><p>3、能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？</p><p>4、runtime如何实现weak变量的自动置nil？</p><p>5、给类添加一个属性后，在类结构体里哪些元素会发生变化？</p><p>类结构</p><p>1、isa指针？（对象的isa，类对象的isa，元类的isa都要说）</p><p>2、类方法和实例方法有什么区别？</p><p>3、介绍一下分类，能用分类做什么？内部是如何实现的？它为什么会覆盖掉原来的方法？</p><p>4、运行时能增加成员变量么？能增加属性么？如果能，如何增加？如果不能，为什么？</p><p>5、objc中向一个nil对象发送消息将会发生什么？（返回值是对象，是标量，结构体）</p><p>高级</p><p>1、UITableview的优化方法（缓存高度，异步绘制，减少层级，hide，避免离屏渲染）</p><p>2、有没有用过运行时，用它都能做什么？（交换方法，创建类，给新创建的类增加方法，改变isa指针）</p><p>3、看过哪些第三方框架的源码？都是如何实现的？（如果没有，问一下多图下载的设计）</p><p>4、SDWebImage的缓存策略？</p><p>5、AFN为什么添加一条常驻线程？</p><p>6、KVO的使用？实现原理？（为什么要创建子类来实现）</p><p>7、KVC的使用？实现原理？（KVC拿到key以后，是如何赋值的？知不知道集合操作符，能不能访问私有属性，能不能直接访问_ivar）</p>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>iOS 个性化视频录制</title>
      <link href="/2017/12/25/iOS%E5%BC%80%E5%8F%91/iOS%20%E4%B8%AA%E6%80%A7%E5%8C%96%E8%A7%86%E9%A2%91%E5%BD%95%E5%88%B6/"/>
      <url>/2017/12/25/iOS%E5%BC%80%E5%8F%91/iOS%20%E4%B8%AA%E6%80%A7%E5%8C%96%E8%A7%86%E9%A2%91%E5%BD%95%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="iOS-个性化视频录制"><a href="#iOS-个性化视频录制" class="headerlink" title="iOS 个性化视频录制"></a>iOS 个性化视频录制</h1><p>##一、简介</p><p>###1.1、工具类<br>自定义视频录制需要用到的框架主要是AVFoundation和CoreMedia，包括视频输出，输入和文件的读写，下面给大家罗列一下将要用到的类：</p><blockquote><p>AVCaptureSession<br>AVCaptureVideoPreviewLayer<br>AVCaptureDeviceInput<br>AVCaptureConnection<br>AVCaptureVideoDataOutput<br>AVCaptureAudioDataOutput<br>AVAssetWriter<br>AVAssetWriterInput</p></blockquote><p>###1.2、AVCaptureSession<br>AVCaptureSession是AVFoundation捕捉类的中心枢纽，我们先从这个类入手，在视频捕获时,客户端可以实例化AVCaptureSession并添加适当的AVCaptureInputs、AVCaptureDeviceInput和输出，比如AVCaptureMovieFileOutput。通过[AVCaptureSession startRunning]开始数据流从输入到输出,和[AVCaptureSession stopRunning]停止输出输入的流动。客户端可以通过设置sessionPreset属性定制录制质量水平或输出的比特率。</p><p>##二、录制</p><p>###2.1、初始化</p><p>###2.2、开始与暂停</p><p>###2.3、前后摄像头</p><p>###2.4、闪光灯</p><p>###2.5、录制设置（时长、工具显隐）</p><p>##三、保存</p><p>###3.1、压缩存储</p><p>###3.2、格式转换</p><p>###3.3、视频预览</p>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
